<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>selfeeg.Augmentation &mdash; SelfEEG 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SelfEEG
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SelfEEG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">selfeeg.Augmentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for selfeeg.Augmentation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">fft</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">torchaudio.functional</span> <span class="kn">import</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">filtfilt</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">torch_pchip</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;identity&#39;</span><span class="p">,</span>
           <span class="s1">&#39;shift_vertical&#39;</span><span class="p">,</span> <span class="s1">&#39;shift_horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;shift_frequency&#39;</span>
           <span class="s1">&#39;flip_vertical&#39;</span><span class="p">,</span> <span class="s1">&#39;flip_horizontal&#39;</span><span class="p">,</span>
           <span class="s1">&#39;scaling&#39;</span><span class="p">,</span><span class="s1">&#39;random_slope_scale&#39;</span><span class="p">,</span> <span class="s1">&#39;random_FT_phase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;add_gaussian_noise&#39;</span><span class="p">,</span> <span class="s1">&#39;add_noise_SNR&#39;</span><span class="p">,</span><span class="s1">&#39;add_band_noise&#39;</span><span class="p">,</span> <span class="s1">&#39;add_eeg_artifact&#39;</span><span class="p">,</span>
           <span class="s1">&#39;moving_avg&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_lowpass&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_highpass&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_bandpass&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_bandstop&#39;</span><span class="p">,</span>
           <span class="s1">&#39;get_eeg_channel_network_names&#39;</span><span class="p">,</span> <span class="s1">&#39;get_channel_map_and_networks&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;permute_channels&#39;</span><span class="p">,</span> <span class="s1">&#39;permutation_signal&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;warp_signal&#39;</span><span class="p">,</span> <span class="s1">&#39;crop_and_resize&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;change_ref&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;masking&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_dropout&#39;</span><span class="p">,</span>
           <span class="s1">&#39;StaticSingleAug&#39;</span><span class="p">,</span> <span class="s1">&#39;DynamicSingleAug&#39;</span><span class="p">,</span> <span class="s1">&#39;SequentialAug&#39;</span>
          <span class="p">]</span>


<span class="c1"># ----- SHIFTS AND FLIPS -------</span>
<div class="viewcode-block" id="identity"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.identity">[docs]</a><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    identity return the same array or tensor as it was given.</span>
<span class="sd">    It can be used during augmentation composition to randomly avoid some augmentations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="shift_vertical"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.shift_vertical">[docs]</a><span class="k">def</span> <span class="nf">shift_vertical</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span> 
                   <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    shift_vertical add a scalar value to the input array x.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">    value: scalar</span>
<span class="sd">        The value to add</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># To do: batch equal and random shift from +- 10 uV random number</span>
    <span class="n">x_shift</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">x_shift</span></div>

<div class="viewcode-block" id="shift_horizontal"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.shift_horizontal">[docs]</a><span class="k">def</span> <span class="nf">shift_horizontal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
                     <span class="n">shift_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">forward</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">random_shift</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    shift_horizontal shift temporally the elements of the last dimension of x by a constant.</span>
<span class="sd">    </span>
<span class="sd">    The empty elements at beginning or the ending part after shift are set to zero.</span>
<span class="sd">    </span>
<span class="sd">    Paramters</span>
<span class="sd">    ---------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        Array to shift. Last dimension must have the EEG recordings</span>
<span class="sd">    shift_time: float</span>
<span class="sd">        Shift in seconds, of the desired time shift.</span>
<span class="sd">    Fs: float</span>
<span class="sd">        the EEG sampling rate in Hz</span>
<span class="sd">    forward: bool</span>
<span class="sd">        Whether to shift the EEG forward (True) or backward (False) in time. If left to None, a</span>
<span class="sd">        random selection of the shift direction will be performed.</span>
<span class="sd">        Default= None</span>
<span class="sd">    random_shift: bool, optional</span>
<span class="sd">        Wheter to choose a random shift length lower than or equal to shift_time, </span>
<span class="sd">        i.e. consider shift_time as the exact value to shift or as an upper bound for </span>
<span class="sd">        a random selection.</span>
<span class="sd">        Default= False</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same shift to all EEG record or not.</span>
<span class="sd">        Note: if random shift is set to False and forward is None, then batch_equal will be equal</span>
<span class="sd">        to True since no differences in the shift can be applied.</span>
<span class="sd">        Default= True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">shift_time</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shift time must be a positive value. To shift backward set forward to False&#39;</span><span class="p">)</span>
    <span class="n">Ndim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_shift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">batch_equal</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">random_shift</span> <span class="ow">or</span> <span class="p">(</span><span class="n">forward</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;set batch equal to true&#39;</span><span class="p">)</span>
            <span class="n">batch_equal</span><span class="o">=</span><span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">forward</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">forward</span><span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">random_shift</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shift_time</span><span class="o">*</span><span class="n">Fs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shift_time</span><span class="o">*</span><span class="n">Fs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">forward</span><span class="p">:</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">shift</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">shift</span><span class="p">:]</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="n">shift</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_shift</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift_horizontal</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift_time</span><span class="o">=</span><span class="n">shift_time</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">forward</span><span class="o">=</span> <span class="n">forward</span><span class="p">,</span>
                                          <span class="n">random_shift</span><span class="o">=</span><span class="n">random_shift</span><span class="p">,</span> <span class="n">batch_equal</span><span class="o">=</span><span class="n">batch_equal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_shift</span></div>
    

<span class="k">def</span> <span class="nf">_UnitStep</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _UnitStep create a numpy array or pytorch tensor with shape equal to x </span>
<span class="sd">    and with the last dimension filled with the step function values used in the Hilbert Transform.</span>
<span class="sd">    This is used to speed up the computation of shift_frequency when batch_equal is set to False.</span>
<span class="sd">    In short, it avoids initializing the same h multiple times. </span>

<span class="sd">    For more info see SciPy&#39;s hilbert help and source code:</span>
<span class="sd">    https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert.html</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">h</span>
    

<span class="k">def</span> <span class="nf">torch_hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    torch_hilbert is a minimal version of SciPy&#39;s hilbert function adapted for pytorch tensors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">        Tensor with signal data.</span>
<span class="sd">    h : torch.Tensor, optional</span>
<span class="sd">        Tensor with the UnitStep function. If not given, it will be initialized during call.</span>
<span class="sd">        Default: None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Xa : torch.Tensor</span>
<span class="sd">        The analytic signal of x calculated along the last dimension of x</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For more info see SciPy&#39;s hilbert help and source code:</span>
<span class="sd">    https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_complex</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be real tensor.&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">Xa</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">Xa</span>
    

<span class="k">def</span> <span class="nf">_shift_frequency</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
                     <span class="n">shift_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">forward</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">random_shift</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">t</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">h</span><span class="o">=</span> <span class="kc">None</span>
                    <span class="p">):</span>
    <span class="k">if</span> <span class="n">shift_freq</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shift freq must be a positive value.&#39;</span>
                         <span class="s1">&#39; To shift backward set forward to False&#39;</span><span class="p">)</span>
    <span class="n">Ndim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_shift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">batch_equal</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">random_shift</span> <span class="ow">or</span> <span class="p">(</span><span class="n">forward</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;set batch equal to true&#39;</span><span class="p">)</span>
            <span class="n">batch_equal</span><span class="o">=</span><span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift_freq</span>
        <span class="k">if</span> <span class="n">forward</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">forward</span><span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">getrandbits</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">random_shift</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">shift_freq</span><span class="p">,</span> <span class="n">shift_freq</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span> <span class="ow">and</span> <span class="n">shift</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span>
        
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">T</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Fs</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span><span class="o">*</span><span class="n">T</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">:(</span><span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">)]</span> 

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">Xa</span> <span class="o">=</span> <span class="n">torch_hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch_hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
            <span class="n">x_shift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Xa</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">shift</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xa</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">h</span> <span class="p">)</span>
            <span class="n">x_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Xa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">shift</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_shift</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_shift_frequency</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shift_freq</span><span class="o">=</span><span class="n">shift_freq</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">forward</span><span class="o">=</span> <span class="n">forward</span><span class="p">,</span>
                                          <span class="n">random_shift</span><span class="o">=</span><span class="n">random_shift</span><span class="p">,</span> <span class="n">batch_equal</span><span class="o">=</span><span class="n">batch_equal</span><span class="p">,</span> 
                                          <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_shift</span>


<span class="k">def</span> <span class="nf">shift_frequency</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
                    <span class="n">shift_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">forward</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">random_shift</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="p">):</span>
    <span class="n">T</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Fs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span><span class="o">*</span><span class="n">T</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">T</span><span class="p">:(</span><span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">)]</span> 
    <span class="n">h</span> <span class="o">=</span> <span class="n">_UnitStep</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_shift_frequency</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift_freq</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">random_shift</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">flip_vertical</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;Array like&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    flip_vertical change the sign of all the elements of the input array x.</span>
<span class="sd">    </span>
<span class="sd">    Paramters</span>
<span class="sd">    ---------</span>
<span class="sd">    x: array like</span>
<span class="sd">        Array to flip. Last dimension must have the EEG recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TO DO: add batch_equal to apply flip only on certain EEGs</span>
    <span class="n">x_flip</span><span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_flip</span>


<div class="viewcode-block" id="flip_horizontal"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.flip_horizontal">[docs]</a><span class="k">def</span> <span class="nf">flip_horizontal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array like&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    flip_horizontal flip the elements of the last dimension of x.</span>
<span class="sd">    </span>
<span class="sd">    Paramters</span>
<span class="sd">    ---------</span>
<span class="sd">    x: array like</span>
<span class="sd">        Array to flip. Last dimension must have the EEG recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TO DO: add batch_equal to apply flip only on certain EEGs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_flip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_flip</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">x_flip</span></div>


<span class="c1"># ---- NOISE ADDER -----</span>
<div class="viewcode-block" id="add_gaussian_noise"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.add_gaussian_noise">[docs]</a><span class="k">def</span> <span class="nf">add_gaussian_noise</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span> 
                       <span class="n">mean</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> 
                       <span class="n">std</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                       <span class="n">get_noise</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    add_gaussian_noise add gaussian noise with the desired mean and standard deviation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: &#39;array like&#39;</span>
<span class="sd">        array to add noise</span>
<span class="sd">    mean: scalar, optional</span>
<span class="sd">        the mean of the gaussian distribution</span>
<span class="sd">        Default: 0</span>
<span class="sd">    std: scalar, optional</span>
<span class="sd">        the std of the gaussian distribution</span>
<span class="sd">        Default: 1</span>
<span class="sd">    get_noise: bool, optional</span>
<span class="sd">        whether to return the generated noise or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise</span>   <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span>  <span class="n">std</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">x_noise</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">noise</span> 
    <span class="k">if</span> <span class="n">get_noise</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span><span class="p">,</span> <span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span></div>

    
<div class="viewcode-block" id="add_noise_SNR"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.add_noise_SNR">[docs]</a><span class="k">def</span> <span class="nf">add_noise_SNR</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span> 
                  <span class="n">target_snr</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                  <span class="n">get_noise</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                 <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    add_noise_SNR add noise such that the SNR (Signal to Noise Ratio) will be the one desired.</span>
<span class="sd">    </span>
<span class="sd">    Since the signal is supposed to be already noisy, it makes more sense to say that this </span>
<span class="sd">    function reduce the SNR by a factor equal to 1/P_noise_new, where P_noise_new is the power </span>
<span class="sd">    of the new added noise.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        array to add noise</span>
<span class="sd">    target_SNR: scalar, optional</span>
<span class="sd">        the target SNR</span>
<span class="sd">        Default: 5</span>
<span class="sd">    get_noise: bool, optional</span>
<span class="sd">        whether to return the generated noise or not</span>
<span class="sd">        Default: False</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    created using the following reference: </span>
<span class="sd">        https://stackoverflow.com/questions/14058340/adding-noise-to-a-signal-in-python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># get signal power. Not exactly true since we have an already noised signal</span>
    <span class="n">x_pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_pow</span><span class="p">)</span>
        <span class="n">x_pow_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_pow</span><span class="p">)</span>
        <span class="n">x_db_avg</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_pow_avg</span><span class="p">)</span> 
        <span class="n">noise_db_avg</span> <span class="o">=</span> <span class="n">x_db_avg</span> <span class="o">-</span> <span class="n">target_snr</span>
        <span class="n">noise_pow_avg</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">noise_db_avg</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">noise_pow_avg</span><span class="o">**</span><span class="mf">0.5</span> <span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> 
        <span class="n">x_noise</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">noise</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_pow</span><span class="p">)</span>
        <span class="n">x_pow_avg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_pow</span><span class="p">)</span>
        <span class="n">x_db_avg</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_pow_avg</span><span class="p">)</span>
        <span class="n">noise_db_avg</span> <span class="o">=</span> <span class="n">x_db_avg</span> <span class="o">-</span> <span class="n">target_snr</span>
        <span class="n">noise_pow_avg</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">noise_db_avg</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="p">((</span><span class="n">noise_pow_avg</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)))</span>
        <span class="n">x_noise</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">noise</span>        
    
    <span class="k">if</span> <span class="n">get_noise</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span><span class="p">,</span> <span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span></div>


<div class="viewcode-block" id="add_band_noise"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.add_band_noise">[docs]</a><span class="k">def</span> <span class="nf">add_band_noise</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array like&quot;</span><span class="p">,</span>
                   <span class="n">bandwidth</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> 
                   <span class="n">samplerate</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                   <span class="n">noise_range</span><span class="p">:</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">std</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">get_noise</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                  <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;add_band noise add random noise filtered at specific bandwidths.</span>
<span class="sd">    </span>
<span class="sd">    Given a set of bandwidths or a set of specific frequency, add_band_noise create a noise whose </span>
<span class="sd">    spectrum is bigger than zero only on those bands. It can be used to alter only specific </span>
<span class="sd">    frequency components of the original signal. The noise generated will have the same standard </span>
<span class="sd">    deviation as x, but it can be rescaled so to be within a specific range or to have a specific </span>
<span class="sd">    standard deviation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: array like</span>
<span class="sd">        array to add noise</span>
<span class="sd">    bandwidth: list</span>
<span class="sd">        The frequency components which the noise must have. Must be a LIST with the following </span>
<span class="sd">        values:</span>
<span class="sd">        </span>
<span class="sd">        - strings: add noise to specific EEG components. Can be any of &quot;delta&quot;, &quot;theta&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;gamma_low&quot;, &quot;gamma_high&quot;.</span>
<span class="sd">        </span>
<span class="sd">        - scalar: add noise to a specifi component </span>
<span class="sd">        </span>
<span class="sd">        - tuple with 2 scalar: add noise to a specific band set with the tuple (start_component,end_component)</span>
<span class="sd">    </span>
<span class="sd">    samplerate: float, optional</span>
<span class="sd">        The sampling rate, given in Hz. Remember to change this value according to the signal </span>
<span class="sd">        sampling rate</span>
<span class="sd">        Default = **256**</span>
<span class="sd">    noise_range: float, optional</span>
<span class="sd">        The range within the noise is scaled. Must be a single sclar or a two element list. If given </span>
<span class="sd">        as a single scalar, then the range is considered the interval [-noise_range, noise_range]. If </span>
<span class="sd">        this parameter is given, then std value is ignored, since the two conditions cannot be </span>
<span class="sd">        satisfied at the same time. To rescale, the following formula is applied:</span>

<span class="sd">        .. math:: </span>
<span class="sd">            noise_new = ( (noise - \max_{noise})/(\max_{noise}-\min_{noise}) )*(target_range_max - target_range_min) + target_range_min</span>
<span class="sd">        </span>
<span class="sd">        Default = **None**</span>
<span class="sd">    std: float, optional</span>
<span class="sd">        The desired standard deviation of the noise. If noise_range is given, this argument is </span>
<span class="sd">        ignored. It simply scale the noise by applying:</span>
<span class="sd">        </span>
<span class="sd">        .. math:: </span>
<span class="sd">            noise_new = noise * (target_std / std(noise))</span>
<span class="sd">        </span>
<span class="sd">        Default = **None**</span>
<span class="sd">    get_noise: bool, optional</span>
<span class="sd">        whether to return the generated noise or not</span>
<span class="sd">        Default = **False**</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># converting to list if single string or integer is given</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">bandwidth</span><span class="o">=</span><span class="p">[</span><span class="n">bandwidth</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">noise_range</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_range</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">noise_range</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">noise_range</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;if given as a list, noise_range must be of length 2&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noise_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">noise_range</span><span class="p">,</span> <span class="n">noise_range</span><span class="p">]</span> <span class="k">if</span> <span class="n">noise_range</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">noise_range</span><span class="p">,</span> <span class="o">-</span><span class="n">noise_range</span><span class="p">]</span>
    
    <span class="c1"># transform all elements in 2 floats tuple</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">)):</span>
        <span class="c1"># change string bandwidth call to frequency slice</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;delta&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma_low&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">70</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma_high&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
                <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span>  <span class="o">=</span> <span class="s1">&#39;Brainwave </span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1"> not exist. </span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s1">&#39;Choose between delta, theta, alpha, beta, gamma, gamma_low, gamma_high&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        
        <span class="c1"># change single frequency call</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>                
            <span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">)</span>          
    <span class="n">samples</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">samples</span><span class="o">/</span><span class="n">samplerate</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">samples</span><span class="o">/</span><span class="n">samplerate</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Np</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">phases</span>
        <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">Np</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Np</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">noise_range</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">std</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span> <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">noise</span> <span class="o">*=</span> <span class="n">G</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_noise</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">min_noise</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">range_noise</span><span class="o">=</span> <span class="n">max_noise</span><span class="o">-</span><span class="n">min_noise</span>
            <span class="n">target_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">noise</span><span class="o">=</span> <span class="p">((</span><span class="n">noise</span> <span class="o">-</span> <span class="n">min_noise</span><span class="p">)</span><span class="o">/</span><span class="n">range_noise</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">target_range</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_noise</span><span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">noise</span>
               
    <span class="k">else</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s1">&#39;mps&#39;</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">samples</span><span class="o">/</span><span class="n">samplerate</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">samples</span><span class="o">/</span><span class="n">samplerate</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="p">(</span><span class="n">samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">phases</span> <span class="o">=</span>  <span class="n">phases</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Np</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">phases</span>
        <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="n">Np</span><span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Np</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s1">&#39;mps&#39;</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;mps&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">noise_range</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">std</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span> <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">noise</span> <span class="o">*=</span> <span class="n">G</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_noise</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">min_noise</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">range_noise</span><span class="o">=</span> <span class="n">max_noise</span><span class="o">-</span><span class="n">min_noise</span>
            <span class="n">target_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noise_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">noise</span><span class="o">=</span> <span class="p">((</span><span class="n">noise</span> <span class="o">-</span> <span class="n">min_noise</span><span class="p">)</span><span class="o">/</span><span class="n">range_noise</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">target_range</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_noise</span><span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">noise</span>

    
    <span class="k">if</span> <span class="n">get_noise</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span> <span class="p">,</span> <span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_noise</span></div>

<div class="viewcode-block" id="scaling"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.scaling">[docs]</a><span class="k">def</span> <span class="nf">scaling</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s1">&#39;array like&#39;</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
           <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    scaling rescale the array by a given amplitude.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: array like</span>
<span class="sd">        Input array or tensor. Can be of any shape, but the last two dimensions must referres to EEG&#39;s Channel x Sample</span>
<span class="sd">    value: float, optional</span>
<span class="sd">        The rescaling factor. If not given, a random value is extracted from a uniform distribution in range [0.5, 2]</span>
<span class="sd">        Default: None</span>
<span class="sd">    batch_equal:</span>
<span class="sd">        Whether to apply the same rescaling on all signals or not. If False, value must be left to None, otherwise</span>
<span class="sd">        batch_equal will be reset to True.</span>
<span class="sd">        Default: True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_scale</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">batch_equal</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">batch_equal</span><span class="o">=</span><span class="kc">True</span> <span class="c1"># speed up computation</span>
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x_scale</span> <span class="o">*=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_scale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaling</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_scale</span></div>

    
<div class="viewcode-block" id="random_slope_scale"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.random_slope_scale">[docs]</a><span class="k">def</span> <span class="nf">random_slope_scale</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
                       <span class="n">min_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                       <span class="n">max_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                       <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">keep_memory</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    random_slope_scale randomly scale the first derivative of x</span>
<span class="sd">    </span>
<span class="sd">    Given a tensor N-D tensor or numpy array where the last two dimensions represents (EEG_channels x EEG_samples) </span>
<span class="sd">    (1D tensor are also accepted), random_slope_scale calculates the first derivatives of each EEG records, here </span>
<span class="sd">    simplified as the difference between two consecutive values of the last dimension, and rescale each of them with</span>
<span class="sd">    a random factor selected from an uniform distribution between min_scale and max_scale. This transformation </span>
<span class="sd">    is similar to adding a random noise, but with the constraint that first derivatise must keep the sign of the </span>
<span class="sd">    original EEG (e.g. if a value is bigger than the previous one, then this is also true in the transformed data, </span>
<span class="sd">    although with the difference is not same).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        The element to rescale. x can be one dimensional. If x has more than one dimension, the last two must </span>
<span class="sd">        represent (EEG_channels x EEG_samples) </span>
<span class="sd">    min_scale: float, optional</span>
<span class="sd">        The minimum rescaling factor to be applied. Must be a value bigger than 0</span>
<span class="sd">        Default: 0.9</span>
<span class="sd">    max_scale: float, optional</span>
<span class="sd">        The maximum rescaling factor to be applied. Must be a value bigger than min_scale</span>
<span class="sd">        Default: 1.2</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same rescale to all EEGs in the batch or not. This apply if x has more than 2 dimensions.</span>
<span class="sd">        Default: False</span>
<span class="sd">    keep_memory: bool, optional</span>
<span class="sd">        whether to keep memory of the previous changes in slope and accumulate them during transformation or not. </span>
<span class="sd">        Basically, instead of using: </span>
<span class="sd">                x_hat(n)= x(n-1) + scaling*( x(n)-x(n-1) ) ; n&gt;1, x_hat transformed signal, x original signal</span>
<span class="sd">        keep_memory apply the following:</span>
<span class="sd">                x_hat(n)= x_hat(n-1) + scaling*( x(n)-x(n-1) ) ; n&gt;1, x_hat transformed signal, x original signal</span>
<span class="sd">        Keep in mind that this may completely change the range of values, as consecutive increase in the slopes</span>
<span class="sd">        may cause a strong vertical shift of the signal. If set to True, set scaling factor in the range [0.8, 1.2]</span>
<span class="sd">        Default: False</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_scale</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;minimum scaling factor can</span><span class="se">\&#39;</span><span class="s1">t be lower than 0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_scale</span><span class="o">&lt;=</span><span class="n">min_scale</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;maximum scaling factor can</span><span class="se">\&#39;</span><span class="s1">t be lower than minimum scaling factor&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">batch_equal</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">scale_factor</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">min_scale</span><span class="p">,</span> <span class="n">max_scale</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_factor</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">min_scale</span><span class="p">,</span> <span class="n">max_scale</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">scale_factor</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">min_scale</span><span class="p">,</span> <span class="n">max_scale</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_factor</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">min_scale</span><span class="p">,</span> <span class="n">max_scale</span><span class="p">)</span>
    
    <span class="n">x_diff</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_diff_scaled</span> <span class="o">=</span> <span class="n">x_diff</span><span class="o">*</span><span class="n">scale_factor</span>
    <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">x_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">keep_memory</span><span class="p">:</span>
        <span class="n">x_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x_diff_scaled</span><span class="p">,</span> <span class="n">Ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x_diff_scaled</span><span class="p">,</span> <span class="n">Ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span>  <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_diff_scaled</span>
    
    <span class="k">return</span> <span class="n">x_new</span>    </div>


<span class="k">def</span> <span class="nf">new_random_fft_phase_odd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">to_torch_tensor</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">to_torch_tensor</span><span class="p">:</span>
        <span class="n">random_phase</span> <span class="o">=</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">new_random_phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]),</span> <span class="n">random_phase</span><span class="p">,</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">random_phase</span><span class="p">)))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">random_phase</span> <span class="o">=</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">new_random_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">random_phase</span><span class="p">,</span> <span class="o">-</span><span class="n">random_phase</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">new_random_phase</span>

<span class="k">def</span> <span class="nf">new_random_fft_phase_even</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">to_torch_tensor</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">to_torch_tensor</span><span class="p">:</span>
        <span class="n">random_phase</span> <span class="o">=</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_random_phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]),</span> <span class="n">random_phase</span><span class="p">,</span>
                                      <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]),</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">random_phase</span><span class="p">)))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">random_phase</span> <span class="o">=</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_random_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">random_phase</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="o">-</span><span class="n">random_phase</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">new_random_phase</span>


<div class="viewcode-block" id="random_FT_phase"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.random_FT_phase">[docs]</a><span class="k">def</span> <span class="nf">random_FT_phase</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array like&quot;</span><span class="p">,</span> 
                    <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    random_FT_phase randomize the phase of all signals in tensor/array x.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: array like</span>
<span class="sd">        Input array or tensor. Can be of any shape, but the last two dimensions must referres to EEG&#39;s Channel x Sample</span>
<span class="sd">    value: float, optional</span>
<span class="sd">        The magnitude of the phase perturbation. It must be a value between (0,1], which will be used to rescale the interval</span>
<span class="sd">        [0, 2* &#39;pi&#39;] in [0, value * 2 * &#39;pi&#39;]</span>
<span class="sd">        Default: None</span>
<span class="sd">    batch_equal:</span>
<span class="sd">        Whether to apply the same perturbation on all signals or not. Note that all channels of the same records will be </span>
<span class="sd">        perturbed in the same way to preserve cross-channel correlations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">value</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;value must be a float in range (0,1]&#39;</span><span class="p">)</span>
    <span class="n">Ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">random_phase</span> <span class="o">=</span> <span class="n">new_random_fft_phase_even</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">new_random_fft_phase_odd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">FT_coeff</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x_phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FT_coeff</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">value</span><span class="o">*</span><span class="n">random_phase</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_phase</span> <span class="o">=</span> <span class="n">new_random_fft_phase_even</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">new_random_fft_phase_odd</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">FT_coeff</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x_phase</span> <span class="o">=</span>  <span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FT_coeff</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">value</span><span class="o">*</span><span class="n">random_phase</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>      
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_phase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_FT_phase</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_phase</span></div>

    
    
<span class="c1"># ---- FILTERING -----</span>
<div class="viewcode-block" id="moving_avg"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.moving_avg">[docs]</a><span class="k">def</span> <span class="nf">moving_avg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    moving_avg apply a moving average filter to the signal x.</span>
<span class="sd">    </span>
<span class="sd">    moving_avg apply a moving average filter to the last dimension of the array or Tensor x. The filter order</span>
<span class="sd">    and can be given as function argument.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        The element to filter. Signals must be on the last dimension.</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">        Default: 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">/</span><span class="n">order</span>
        <span class="n">Ndim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="c1"># call recursively to handle different dimensions (made to handle problem with torch conv2d)</span>
        <span class="k">if</span> <span class="n">Ndim</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">x_avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">moving_avg</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># adapt to x to conv2d functions</span>
        <span class="k">if</span> <span class="n">Ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_avg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">order</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">/</span><span class="n">order</span>
        
        <span class="c1"># call recursively if the dimension is larger than 4</span>
        <span class="k">if</span> <span class="n">Ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">x_avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">moving_avg</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_avg</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
            <span class="n">x_avg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_avg</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    
    <span class="k">return</span> <span class="n">x_avg</span></div>


<span class="k">def</span> <span class="nf">get_filter_coeff</span><span class="p">(</span><span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">Wp</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                     <span class="n">Ws</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">rp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> 
                     <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.15</span><span class="p">),</span> 
                     <span class="n">btype</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> 
                     <span class="n">filter_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> 
                     <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">Wn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">eeg_band</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    get_filter_coeff returns the filter coefficients a and b needed to call the scipy&#39;s or torchaudio&#39;s </span>
<span class="sd">    filtfilt function.</span>
<span class="sd">    </span>
<span class="sd">    get_filter_coeff is internally called by other filtering function when a and b coefficients are not given</span>
<span class="sd">    as input argument. It works following this priority pipeline:</span>
<span class="sd">    1) if specific EEG bands are given, set Wp, Ws, rp, rs for filter design according to the given band</span>
<span class="sd">    2) if order and Wn are not given, use previous parameter to design the filter</span>
<span class="sd">    3) Use Wn and order to get a and b coefficient to return</span>
<span class="sd">    </span>
<span class="sd">    In other words (Wp,Ws,rp,rs) ----&gt; (Wn, order) -----&gt; (a,b) </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    Wp: float</span>
<span class="sd">        bandpass normalized from 0 to 1</span>
<span class="sd">    Ws: float</span>
<span class="sd">        stopband normalized from 0 to 1</span>
<span class="sd">    rp: float, optional</span>
<span class="sd">        ripple at bandpass in decibel. </span>
<span class="sd">        Default: -20*log10(0.95)</span>
<span class="sd">    rs: float, optional</span>
<span class="sd">        ripple at stopband in decibel. </span>
<span class="sd">        Default: -20*log10(0.15)</span>
<span class="sd">    btype: str, optional</span>
<span class="sd">        filter type. Can be any of the scipy&#39;s btype argument (e.g. &#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;)</span>
<span class="sd">        Default: &#39;low&#39;</span>
<span class="sd">    filter_type: str, optional</span>
<span class="sd">        which filter design. Accepted values are &#39;butter&#39;, &#39;ellip&#39;, &#39;cheby1&#39;, &#39;cheby2&#39;</span>
<span class="sd">        Default: &#39;butter&#39;</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        the order of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    Wn: array_like, optional</span>
<span class="sd">        the critical frequency or frequencies.</span>
<span class="sd">        Default: None</span>
<span class="sd">    eeg_band: str, optional</span>
<span class="sd">        any of the possible EEG bands. Accepted values are &quot;delta&quot;, &quot;theta&quot;, &quot;alpha&quot;, &quot;beta&quot;, </span>
<span class="sd">        &quot;gamma&quot;, &quot;gamma_low&quot;, &quot;gamma_high&quot;.</span>
<span class="sd">        Default: None</span>
<span class="sd">    Fs: float, optional</span>
<span class="sd">        the sampling frequency. Must be given if eeg_band is also given</span>
<span class="sd">        Default: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">eeg_band</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;delta&#39;</span><span class="p">:</span>
                <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;highpass&#39;</span> <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;lowpass&#39;</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span>
                <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span>
                <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span>
                <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.15</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma_low&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Fs</span><span class="o">&gt;=</span><span class="mi">78</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span> <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;highpass&#39;</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma_high&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Fs</span><span class="o">&gt;=</span><span class="mi">158</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">70</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">160</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span> <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;highpass&#39;</span>
            <span class="k">elif</span> <span class="n">eeg_band</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Fs</span><span class="o">&gt;=</span><span class="mi">158</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">160</span><span class="p">],</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.1</span><span class="p">),</span> <span class="s1">&#39;highpass&#39;</span>
                    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span> <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;highpass&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span>  <span class="o">=</span> <span class="s1">&#39;Brainwave </span><span class="se">\&quot;</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">bandwidth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\&quot;</span><span class="s1"> not exist. </span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s1">&#39;Choose between delta, theta, alpha, beta, gamma, gamma_low, gamma_high&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">btype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">:</span>
                <span class="c1"># simply reverse bandpass and stopband</span>
                <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">Wp</span>
    
    <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Wp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ws</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Wn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;butter&#39;</span><span class="p">:</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">buttord</span><span class="p">(</span><span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;ellip&#39;</span><span class="p">:</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellipord</span><span class="p">(</span><span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cheby1&#39;</span><span class="p">:</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cheb1ord</span><span class="p">(</span><span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cheby2&#39;</span><span class="p">:</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cheb2ord</span><span class="p">(</span><span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;butter&#39;</span><span class="p">:</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;ellip&#39;</span><span class="p">:</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellip</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cheby1&#39;</span><span class="p">:</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cheby1</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">rp</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filter_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;cheby2&#39;</span><span class="p">:</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cheby2</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="c1"># SISTEMA WP E WS (METTI FS PER CAPIRE SE NORMALIZZARE O MENO)</span>
<div class="viewcode-block" id="filter_lowpass"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.filter_lowpass">[docs]</a><span class="k">def</span> <span class="nf">filter_lowpass</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array or tensor&quot;</span><span class="p">,</span>
                   <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                   <span class="n">Wp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                   <span class="n">Ws</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
                   <span class="n">rp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> 
                   <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.15</span><span class="p">),</span>
                   <span class="n">filter_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span>
                   <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                   <span class="n">Wn</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">return_filter_coeff</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    filter_lowpass apply a lowpass filter on the last dimension of the given input x.</span>
<span class="sd">    </span>
<span class="sd">    filter_lowpass apply a designed lowpass filter on the last dimension of x. If a and b coefficient are not </span>
<span class="sd">    given, calls get_filter_coeff with the other arguments to get them. The filter dedign follow this order:</span>
<span class="sd">                            (Wp,Ws,rp,rs) ----&gt; (Wn, order) -----&gt; (a,b). </span>
<span class="sd">    Therefore the arguments closer to a and b in the scheme are used to get the filter coefficient.</span>

<span class="sd">    NOTE 1: lots of parameters are the ones used to call scipy&#39;s matlab style filters, ASIDE TO &#39;Wp&#39; and &#39;Ws&#39; which</span>
<span class="sd">    you must give directly in Hz. The normalization to [0,1] with respect to the half-cycles / sample </span>
<span class="sd">    (i.e. Nyquist frequency) is done directly inside the get_filter_coeff function</span>

<span class="sd">    NOTE 2: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D array or Tensor</span>
<span class="sd">        The element to filter</span>
<span class="sd">    Fs: float</span>
<span class="sd">        the sampling frequency in Hz</span>
<span class="sd">    Wp: float, optional</span>
<span class="sd">        bandpass in Hz</span>
<span class="sd">        Default: 50</span>
<span class="sd">    Ws: float, optional</span>
<span class="sd">        stopband in Hz</span>
<span class="sd">        Default: 70</span>
<span class="sd">    rp: float, optional</span>
<span class="sd">        ripple at bandpass in decibel. </span>
<span class="sd">        Default: -20*log10(0.95)</span>
<span class="sd">    rs: float, optional</span>
<span class="sd">        ripple at stopband in decibel. </span>
<span class="sd">        Default: -20*log10(0.15)</span>
<span class="sd">    filter_type: str, optional</span>
<span class="sd">        which filter design. Accepted values are &#39;butter&#39;, &#39;ellip&#39;, &#39;cheby1&#39;, &#39;cheby2&#39;</span>
<span class="sd">        Default: &#39;butter&#39;</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        the order of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    Wn: array_like, optional</span>
<span class="sd">        the critical frequency or frequencies.</span>
<span class="sd">        Default: None</span>
<span class="sd">    a: array_like, optional</span>
<span class="sd">        the denominator coefficient of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    b: array_like, optional</span>
<span class="sd">        the numerator coefficient of the filer</span>
<span class="sd">        Default: None</span>
<span class="sd">    return_filter_coeff: bool, optional</span>
<span class="sd">        whether to return the filter coefficient or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby2&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter type not supported. Choose between butter, elliptic, cheby1, cheby2&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_filter_coeff</span><span class="p">(</span><span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">Wp</span> <span class="o">=</span> <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span> 
                                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">eeg_band</span> <span class="o">=</span> <span class="kc">None</span>
                               <span class="p">)</span>
         
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">b</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>   
    
    <span class="k">if</span> <span class="n">return_filter_coeff</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span></div>

    
<div class="viewcode-block" id="filter_highpass"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.filter_highpass">[docs]</a><span class="k">def</span> <span class="nf">filter_highpass</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array or tensor&quot;</span><span class="p">,</span> 
                    <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">Wp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                    <span class="n">Ws</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span>
                    <span class="n">rp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> 
                    <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.15</span><span class="p">),</span>
                    <span class="n">filter_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span>
                    <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">Wn</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">return_filter_coeff</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                   <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    filter_highpass apply a highpass filter on the last dimension of the given input x.</span>
<span class="sd">    </span>
<span class="sd">    filter_highpass apply a designed highpass filter on the last dimension of x. If a and b coefficient are not </span>
<span class="sd">    given, calls get_filter_coeff with the other arguments to get them. The filter dedign follow this order:</span>
<span class="sd">                            (Wp,Ws,rp,rs) ----&gt; (Wn, order) -----&gt; (a,b). </span>
<span class="sd">    Therefore the arguments closer to a and b in the scheme are used to get the filter coefficient.</span>

<span class="sd">    NOTE 1: lots of parameters are the ones used to call scipy&#39;s matlab style filters, ASIDE TO &#39;Wp&#39; and &#39;Ws&#39; which</span>
<span class="sd">    you must give directly in Hz. The normalization to [0,1] with respect to the half-cycles / sample </span>
<span class="sd">    (i.e. Nyquist frequency) is done directly inside the get_filter_coeff function</span>

<span class="sd">    NOTE 2: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D array or Tensor</span>
<span class="sd">        The element to filter</span>
<span class="sd">    Wp: float, optional</span>
<span class="sd">        bandpass in Hz</span>
<span class="sd">        Default: 30</span>
<span class="sd">    Ws: float, optional</span>
<span class="sd">        stopband in Hz</span>
<span class="sd">        Default: 13</span>
<span class="sd">    rp: float, optional</span>
<span class="sd">        ripple at bandpass in decibel. </span>
<span class="sd">        Default: -20*log10(0.95)</span>
<span class="sd">    rs: float, optional</span>
<span class="sd">        ripple at stopband in decibel. </span>
<span class="sd">        Default: -20*log10(0.15)</span>
<span class="sd">    filter_type: str, optional</span>
<span class="sd">        which filter design. Accepted values are &#39;butter&#39;, &#39;ellip&#39;, &#39;cheby1&#39;, &#39;cheby2&#39;</span>
<span class="sd">        Default: &#39;butter&#39;</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        the order of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    Wn: array_like, optional</span>
<span class="sd">        the critical frequency or frequencies.</span>
<span class="sd">        Default: None</span>
<span class="sd">    a: array_like, optional</span>
<span class="sd">        the denominator coefficient of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    b: array_like, optional</span>
<span class="sd">        the numerator coefficient of the filer</span>
<span class="sd">        Default: None</span>
<span class="sd">    return_filter_coeff: bool, optional</span>
<span class="sd">        whether to return the filter coefficient or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby2&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter type not supported. Choose between butter, elliptic, cheby1, cheby2&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_filter_coeff</span><span class="p">(</span><span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">Wp</span> <span class="o">=</span> <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span> 
                                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">,</span><span class="n">eeg_band</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="p">)</span>
         
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span> <span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">b</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>   
    
    <span class="k">if</span> <span class="n">return_filter_coeff</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span></div>


<div class="viewcode-block" id="filter_bandpass"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.filter_bandpass">[docs]</a><span class="k">def</span> <span class="nf">filter_bandpass</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array or tensor&quot;</span><span class="p">,</span>
                    <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">Wp</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">Ws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> 
                    <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.05</span><span class="p">),</span>
                    <span class="n">filter_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span>
                    <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">Wn</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">eeg_band</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">return_filter_coeff</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    filter_bandpass apply a bandpass filter on the last dimension of the given input x.</span>
<span class="sd">    </span>
<span class="sd">    filter_bandpass apply a designed bandpass filter on the last dimension of x. If a and b coefficient are not </span>
<span class="sd">    given, calls get_filter_coeff with the other arguments to get them. The filter dedign follow this order:</span>
<span class="sd">                            (Wp,Ws,rp,rs) ----&gt; (Wn, order) -----&gt; (a,b). </span>
<span class="sd">    Therefore the arguments closer to a and b in the scheme are used to get the filter coefficient.</span>
<span class="sd">    </span>
<span class="sd">    If eeg_band are given, (Wp,Ws,rp,rs) are bypassed and instantiated according to the eeg band specified. The</span>
<span class="sd">    priority order remain, so if (Wn,order) or (a,b) are given, filter is created according to the described priority</span>
<span class="sd">    order</span>

<span class="sd">    NOTE 1: lots of parameters are the ones used to call scipy&#39;s matlab style filters, ASIDE TO &#39;Wp&#39; and &#39;Ws&#39; which</span>
<span class="sd">    you must give directly in Hz. The normalization to [0,1] with respect to the half-cycles / sample </span>
<span class="sd">    (i.e. Nyquist frequency) is done directly inside the get_filter_coeff function</span>

<span class="sd">    NOTE 2: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D array or Tensor</span>
<span class="sd">        The element to filter</span>
<span class="sd">    Fs: float</span>
<span class="sd">        the sampling frequency in Hz</span>
<span class="sd">    Wp: float, optional</span>
<span class="sd">        bandpass in Hz.</span>
<span class="sd">        Default: 30</span>
<span class="sd">    Ws: float, optional</span>
<span class="sd">        stopband in Hz</span>
<span class="sd">        Default: 13</span>
<span class="sd">    rp: float, optional</span>
<span class="sd">        ripple at bandpass in decibel. </span>
<span class="sd">        Default: -20*log10(0.95)</span>
<span class="sd">    rs: float, optional</span>
<span class="sd">        ripple at stopband in decibel. </span>
<span class="sd">        Default: -20*log10(0.15)</span>
<span class="sd">    filter_type: str, optional</span>
<span class="sd">        which filter design. Accepted values are &#39;butter&#39;, &#39;ellip&#39;, &#39;cheby1&#39;, &#39;cheby2&#39;</span>
<span class="sd">        Default: &#39;butter&#39;</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        the order of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    Wn: array_like, optional</span>
<span class="sd">        the critical frequency or frequencies.</span>
<span class="sd">        Default: None</span>
<span class="sd">    a: array_like, optional</span>
<span class="sd">        the denominator coefficient of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    b: array_like, optional</span>
<span class="sd">        the numerator coefficient of the filer</span>
<span class="sd">        Default: None</span>
<span class="sd">    eeg_band: str, optional</span>
<span class="sd">        any of the possible EEG bands. Accepted values are &quot;delta&quot;, &quot;theta&quot;, &quot;alpha&quot;, &quot;beta&quot;, </span>
<span class="sd">        &quot;gamma&quot;, &quot;gamma_low&quot;, &quot;gamma_high&quot;. Note: eeg_band bypass any Wp and Ws, if given</span>
<span class="sd">        Default: None</span>
<span class="sd">    return_filter_coeff: bool, optional</span>
<span class="sd">        whether to return the filter coefficient or not</span>
<span class="sd">        Default: False</span>
<span class="sd">        </span>
<span class="sd">    NOTE: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby2&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter type not supported. Choose between butter, elliptic, cheby1, cheby2&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_filter_coeff</span><span class="p">(</span><span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">Wp</span> <span class="o">=</span> <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> 
                                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">,</span><span class="n">eeg_band</span> <span class="o">=</span> <span class="n">eeg_band</span><span class="p">,</span> 
                               <span class="p">)</span>
         
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span> <span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">b</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="n">return_filter_coeff</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span></div>


<div class="viewcode-block" id="filter_bandstop"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.filter_bandstop">[docs]</a><span class="k">def</span> <span class="nf">filter_bandstop</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;array or tensor&quot;</span><span class="p">,</span>
                    <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="n">Wp</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">Ws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rp</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.95</span><span class="p">),</span> 
                    <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">.05</span><span class="p">),</span>
                    <span class="n">filter_type</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span>
                    <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">Wn</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">eeg_band</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">return_filter_coeff</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    filter_bandstop apply a bandstop filter on the last dimension of the given input x.</span>
<span class="sd">    </span>
<span class="sd">    filter_bandstop apply a designed bandstop filter on the last dimension of x. If a and b coefficient are not </span>
<span class="sd">    given, calls get_filter_coeff with the other arguments to get them. The filter dedign follow this order:</span>
<span class="sd">                            (Wp,Ws,rp,rs) ----&gt; (Wn, order) -----&gt; (a,b). </span>
<span class="sd">    Therefore the arguments closer to a and b in the scheme are used to get the filter coefficient.</span>
<span class="sd">    </span>
<span class="sd">    If eeg_band are given, (Wp,Ws,rp,rs) are bypassed and instantiated according to the eeg band specified. The</span>
<span class="sd">    priority order remain, so if (Wn,order) or (a,b) are given, filter is created according to such parameters.</span>

<span class="sd">    NOTE 1: lots of parameters are the ones used to call scipy&#39;s matlab style filters, ASIDE TO &#39;Wp&#39; and &#39;Ws&#39; which</span>
<span class="sd">    you must give directly in Hz. The normalization to [0,1] with respect to the half-cycles / sample </span>
<span class="sd">    (i.e. Nyquist frequency) is done directly inside the get_filter_coeff function.</span>

<span class="sd">    NOTE 2: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: N-D array or Tensor</span>
<span class="sd">        The element to filter</span>
<span class="sd">    Fs: float</span>
<span class="sd">        the sampling frequency in Hz</span>
<span class="sd">    Wp: float, optional</span>
<span class="sd">        bandpass in Hz.</span>
<span class="sd">        Default: 30</span>
<span class="sd">    Ws: float, optional</span>
<span class="sd">        stopband in Hz</span>
<span class="sd">        Default: 13</span>
<span class="sd">    rp: float, optional</span>
<span class="sd">        ripple at bandpass in decibel. </span>
<span class="sd">        Default: -20*log10(0.95)</span>
<span class="sd">    rs: float, optional</span>
<span class="sd">        ripple at stopband in decibel. </span>
<span class="sd">        Default: -20*log10(0.15)</span>
<span class="sd">    filter_type: str, optional</span>
<span class="sd">        which filter design. Accepted values are &#39;butter&#39;, &#39;ellip&#39;, &#39;cheby1&#39;, &#39;cheby2&#39;</span>
<span class="sd">        Default: &#39;butter&#39;</span>
<span class="sd">    order: int, optional</span>
<span class="sd">        the order of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    Wn: array_like, optional</span>
<span class="sd">        the critical frequency or frequencies.</span>
<span class="sd">        Default: None</span>
<span class="sd">    a: array_like, optional</span>
<span class="sd">        the denominator coefficient of the filter</span>
<span class="sd">        Default: None</span>
<span class="sd">    b: array_like, optional</span>
<span class="sd">        the numerator coefficient of the filer</span>
<span class="sd">        Default: None</span>
<span class="sd">    eeg_band: str, optional</span>
<span class="sd">        any of the possible EEG bands. Accepted values are &quot;delta&quot;, &quot;theta&quot;, &quot;alpha&quot;, &quot;beta&quot;, </span>
<span class="sd">        &quot;gamma&quot;, &quot;gamma_low&quot;, &quot;gamma_high&quot;. Note: eeg_band bypass any Wp and Ws, if given</span>
<span class="sd">        Default: None</span>
<span class="sd">    return_filter_coeff: bool, optional</span>
<span class="sd">        whether to return the filter coefficient or not</span>
<span class="sd">        Default: False</span>
<span class="sd">        </span>
<span class="sd">    NOTE: pytorch filtfilt works differently on edges and is pretty unstable with high order filters, so avoid </span>
<span class="sd">    restrictive condition which can increase the order of the filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby2&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter type not supported. Choose between butter, elliptic, cheby1, cheby2&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_filter_coeff</span><span class="p">(</span><span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">Wp</span> <span class="o">=</span> <span class="n">Wp</span><span class="p">,</span> <span class="n">Ws</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">rs</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span> 
                                <span class="n">filter_type</span> <span class="o">=</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">eeg_band</span> <span class="o">=</span> <span class="n">eeg_band</span> 
                               <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span> <span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">b</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="n">return_filter_coeff</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_filt</span></div>

<span class="c1"># --- PERMUTATIONS ---</span>
<div class="viewcode-block" id="get_eeg_channel_network_names"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.get_eeg_channel_network_names">[docs]</a><span class="k">def</span> <span class="nf">get_eeg_channel_network_names</span><span class="p">():</span>
    
    <span class="n">DMN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF7&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;AFZ&#39;</span><span class="p">,</span> <span class="s1">&#39;CP3&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;F2&#39;</span><span class="p">,</span> <span class="s1">&#39;F3&#39;</span><span class="p">,</span> <span class="s1">&#39;F4&#39;</span><span class="p">,</span> <span class="s1">&#39;F5&#39;</span><span class="p">,</span> <span class="s1">&#39;F6&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC3&#39;</span><span class="p">,</span> <span class="s1">&#39;FC4&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FP1&#39;</span><span class="p">,</span> <span class="s1">&#39;FP2&#39;</span><span class="p">,</span> <span class="s1">&#39;FPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT10&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FT9&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P4&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">DAN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P2&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span> <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">VAN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF3&#39;</span><span class="p">,</span> <span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;CP6&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FT7&#39;</span><span class="p">,</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P2&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span> <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">SMN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FCZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FTZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span><span class="s1">&#39;P6&#39;</span><span class="p">,</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">VFN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FTZ&#39;</span><span class="p">,</span> <span class="s1">&#39;O1&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;OZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span> 
    <span class="n">FPN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF3&#39;</span><span class="p">,</span> <span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF7&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;AFZ&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP3&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CP6&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;F2&#39;</span><span class="p">,</span> <span class="s1">&#39;F3&#39;</span><span class="p">,</span> <span class="s1">&#39;F4&#39;</span><span class="p">,</span> <span class="s1">&#39;F5&#39;</span><span class="p">,</span> <span class="s1">&#39;F6&#39;</span><span class="p">,</span> <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC3&#39;</span><span class="p">,</span> <span class="s1">&#39;FC4&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FP1&#39;</span><span class="p">,</span> <span class="s1">&#39;FP2&#39;</span><span class="p">,</span> <span class="s1">&#39;FPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT10&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FT7&#39;</span><span class="p">,</span> <span class="s1">&#39;FT9&#39;</span><span class="p">,</span> <span class="s1">&#39;FZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P4&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Default Mode Network - DMN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">DMN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dorsal Attention Network - DAN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">DAN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ventral Attention Network - VAN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">VAN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SomatoMotor functional Network - SMN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">SMN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Visual Functional Network - VFN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">VFN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FrontoParietal Network - FPN&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">FPN</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="get_channel_map_and_networks"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.get_channel_map_and_networks">[docs]</a><span class="k">def</span> <span class="nf">get_channel_map_and_networks</span><span class="p">(</span><span class="n">channel_map</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">chan_net</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    get_channel_map_and_networks simply return the channel_map and chan_net argument for permute_channels.</span>
<span class="sd">    Run help(permute_channels) to get more informations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">channel_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;FP1&#39;</span><span class="p">,</span> <span class="s1">&#39;AF7&#39;</span><span class="p">,</span> <span class="s1">&#39;AF3&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;F3&#39;</span><span class="p">,</span> <span class="s1">&#39;F5&#39;</span><span class="p">,</span> <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;FT7&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;FC3&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;CP3&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span> <span class="s1">&#39;O1&#39;</span><span class="p">,</span> <span class="s1">&#39;OZ&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FP2&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AFZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FZ&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;F2&#39;</span><span class="p">,</span> <span class="s1">&#39;F4&#39;</span><span class="p">,</span> <span class="s1">&#39;F6&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FC4&#39;</span><span class="p">,</span> <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FCZ&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;CZ&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">,</span> <span class="s1">&#39;CP6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;P2&#39;</span><span class="p">,</span> <span class="s1">&#39;P4&#39;</span><span class="p">,</span> <span class="s1">&#39;P6&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_map</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">channel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel_map</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    
    <span class="c1"># define networks (according to rojas et al. 2018)</span>
    <span class="n">DMN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF7&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;AFZ&#39;</span><span class="p">,</span> <span class="s1">&#39;CP3&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;F2&#39;</span><span class="p">,</span> <span class="s1">&#39;F3&#39;</span><span class="p">,</span> <span class="s1">&#39;F4&#39;</span><span class="p">,</span> <span class="s1">&#39;F5&#39;</span><span class="p">,</span> <span class="s1">&#39;F6&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC3&#39;</span><span class="p">,</span> <span class="s1">&#39;FC4&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FP1&#39;</span><span class="p">,</span> <span class="s1">&#39;FP2&#39;</span><span class="p">,</span> <span class="s1">&#39;FPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT10&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FT9&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P4&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">DAN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P2&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span> <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">VAN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF3&#39;</span><span class="p">,</span> <span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;CP6&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span> <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FT7&#39;</span><span class="p">,</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="s1">&#39;P2&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span> <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">SMN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FCZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FTZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span><span class="s1">&#39;P6&#39;</span><span class="p">,</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">VFN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="s1">&#39;C5&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP1&#39;</span><span class="p">,</span> <span class="s1">&#39;CP2&#39;</span><span class="p">,</span> <span class="s1">&#39;CPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FT8&#39;</span><span class="p">,</span> <span class="s1">&#39;FTZ&#39;</span><span class="p">,</span> <span class="s1">&#39;O1&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;OZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P7&#39;</span><span class="p">,</span> <span class="s1">&#39;P8&#39;</span><span class="p">,</span> <span class="s1">&#39;PO3&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;PO4&#39;</span><span class="p">,</span> <span class="s1">&#39;PO7&#39;</span><span class="p">,</span> <span class="s1">&#39;PO8&#39;</span><span class="p">,</span> <span class="s1">&#39;POZ&#39;</span><span class="p">,</span> <span class="s1">&#39;PZ&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span> 
    <span class="n">FPN</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;AF3&#39;</span><span class="p">,</span> <span class="s1">&#39;AF4&#39;</span><span class="p">,</span> <span class="s1">&#39;AF7&#39;</span><span class="p">,</span> <span class="s1">&#39;AF8&#39;</span><span class="p">,</span> <span class="s1">&#39;AFZ&#39;</span><span class="p">,</span> <span class="s1">&#39;C6&#39;</span><span class="p">,</span> <span class="s1">&#39;CP3&#39;</span><span class="p">,</span> <span class="s1">&#39;CP4&#39;</span><span class="p">,</span> <span class="s1">&#39;CP5&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;CP6&#39;</span><span class="p">,</span> <span class="s1">&#39;F1&#39;</span><span class="p">,</span> <span class="s1">&#39;F2&#39;</span><span class="p">,</span> <span class="s1">&#39;F3&#39;</span><span class="p">,</span> <span class="s1">&#39;F4&#39;</span><span class="p">,</span> <span class="s1">&#39;F5&#39;</span><span class="p">,</span> <span class="s1">&#39;F6&#39;</span><span class="p">,</span> <span class="s1">&#39;F7&#39;</span><span class="p">,</span> <span class="s1">&#39;F8&#39;</span><span class="p">,</span> <span class="s1">&#39;FC1&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FC2&#39;</span><span class="p">,</span> <span class="s1">&#39;FC3&#39;</span><span class="p">,</span> <span class="s1">&#39;FC4&#39;</span><span class="p">,</span> <span class="s1">&#39;FC5&#39;</span><span class="p">,</span> <span class="s1">&#39;FC6&#39;</span><span class="p">,</span> <span class="s1">&#39;FP1&#39;</span><span class="p">,</span> <span class="s1">&#39;FP2&#39;</span><span class="p">,</span> <span class="s1">&#39;FPZ&#39;</span><span class="p">,</span> <span class="s1">&#39;FT10&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FT7&#39;</span><span class="p">,</span> <span class="s1">&#39;FT9&#39;</span><span class="p">,</span> <span class="s1">&#39;FZ&#39;</span><span class="p">,</span> <span class="s1">&#39;P3&#39;</span><span class="p">,</span> <span class="s1">&#39;P4&#39;</span><span class="p">,</span> <span class="s1">&#39;P5&#39;</span><span class="p">,</span> <span class="s1">&#39;T7&#39;</span><span class="p">,</span> <span class="s1">&#39;T8&#39;</span><span class="p">,</span> <span class="s1">&#39;TP7&#39;</span><span class="p">,</span> <span class="s1">&#39;TP8&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U4&#39;</span><span class="p">)</span>
    <span class="n">networks</span> <span class="o">=</span><span class="p">[</span><span class="n">DMN</span><span class="p">,</span> <span class="n">DAN</span><span class="p">,</span> <span class="n">VAN</span><span class="p">,</span> <span class="n">SMN</span><span class="p">,</span> <span class="n">VFN</span><span class="p">,</span> <span class="n">FPN</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chan_net</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">chan_net</span> <span class="o">=</span> <span class="p">[</span><span class="n">chan_net</span><span class="p">]</span>

    <span class="n">net_idx</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chan_net</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dmn&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dan&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;van&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;smn&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;vfn&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">chan_net</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;fpn&#39;</span><span class="p">:</span>
            <span class="n">net_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;brain network not supported. Can be any of DMN, DAN, VAN, SMN, VFN, FPN&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">net_idx</span><span class="p">)</span> <span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">networks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">networks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">channel_map</span><span class="p">,</span> <span class="n">networks</span></div>
    

<div class="viewcode-block" id="permute_channels"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.permute_channels">[docs]</a><span class="k">def</span> <span class="nf">permute_channels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> 
                     <span class="n">chan2shuf</span><span class="p">:</span> <span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                     <span class="n">channel_map</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">chan_net</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                     <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    permutation_channels permute the input tensor EEG signals x along the channel dimension (second to last).</span>
<span class="sd">    </span>
<span class="sd">    Given an input x where the last two dimension must be (EEG_channels x EEG_samples), permutation_channels </span>
<span class="sd">    shuffles all or a subset of the eeg along its channels. Shuffles can be done randomly or using specific</span>
<span class="sd">    networks (based on resting state functional connectivity networks).</span>
<span class="sd">    If batch_equal is set to False, call the function recursively along each of the (N_{1}*N_{2}...*N{-3}) </span>
<span class="sd">    dimensions of the tensor.</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    </span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        The element to shuffle. The last two dimensions must be (EEG_channel x EEG_samples), which means that the </span>
<span class="sd">        permutation is applied on the second to last dimension. </span>
<span class="sd">    chan2shuf: int, optional</span>
<span class="sd">        The number of channels to shuffle. Must be greater than 1. -1 is the only accepted negative number and </span>
<span class="sd">        means permute all the segments.</span>
<span class="sd">        Default: -1</span>
<span class="sd">    mode: str, optional</span>
<span class="sd">        How to permute the channels. Can be any of:</span>
<span class="sd">            &#39;random&#39;: shuffle channels at random</span>
<span class="sd">            &#39;network&#39;: shuffle channels which belongs to the same network. A network is a subset of channels whose</span>
<span class="sd">                       activity is (with a minumum degree) between each other. This mode support only a subset of</span>
<span class="sd">                       61 channels of the 10-10 system</span>
<span class="sd">        Default: &#39;random&#39;</span>
<span class="sd">    channel_map: list of str, optional</span>
<span class="sd">        The channel map of EEG acquisitions. Must be a list of string or a numpy array of dtype=&#39;&lt;U4&#39; with channel </span>
<span class="sd">        names as elements. Channel name must be defined with capital letters (e.g. &#39;P04&#39;, &#39;FC5&#39;).</span>
<span class="sd">        Default: np.array([&#39;FP1&#39;, &#39;AF7&#39;, &#39;AF3&#39;, &#39;F1&#39;, &#39;F3&#39;, &#39;F5&#39;, &#39;F7&#39;, &#39;FT7&#39;, &#39;FC5&#39;, &#39;FC3&#39;, &#39;FC1&#39;, &#39;C1&#39;, &#39;C3&#39;, </span>
<span class="sd">                            &#39;C5&#39;, &#39;T7&#39;, &#39;TP7&#39;, &#39;CP5&#39;, &#39;CP3&#39;,&#39;CP1&#39;, &#39;P1&#39;, &#39;P3&#39;, &#39;P5&#39;, &#39;P7&#39;, &#39;PO7&#39;, &#39;PO3&#39;, &#39;O1&#39;, </span>
<span class="sd">                            &#39;OZ&#39;, &#39;POZ&#39;, &#39;PZ&#39;, &#39;CPZ&#39;, &#39;FPZ&#39;, &#39;FP2&#39;, &#39;AF8&#39;, &#39;AF4&#39;, &#39;AFZ&#39;, &#39;FZ&#39;, &#39;F2&#39;, &#39;F4&#39;, &#39;F6&#39;, </span>
<span class="sd">                            &#39;F8&#39;, &#39;FT8&#39;, &#39;FC6&#39;, &#39;FC4&#39;, &#39;FC2&#39;, &#39;FCZ&#39;, &#39;CZ&#39;, &#39;C2&#39;, &#39;C4&#39;, &#39;C6&#39;, &#39;T8&#39;, &#39;TP8&#39;, &#39;CP6&#39;, </span>
<span class="sd">                            &#39;CP4&#39;, &#39;CP2&#39;, &#39;P2&#39;, &#39;P4&#39;, &#39;P6&#39;, &#39;P8&#39;, &#39;PO8&#39;, &#39;PO4&#39;],dtype=&#39;&lt;U4&#39;)</span>
<span class="sd">    chan_net: str or list of str, optional</span>
<span class="sd">        The list of networks to use if network mode is selected. Must be a list of string or a single string.</span>
<span class="sd">        Supported networks are DMN, DAN, VAN, SMN, VFN, FPN. Use &#39;all&#39; to select all networks. To get a list of</span>
<span class="sd">        the channel names per network use get_eeg_network_channel_names()</span>
<span class="sd">        Default: &#39;all&#39;</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same permutation to all EEG record or not. If True, permute_signal is called </span>
<span class="sd">        recursively for each dimension of the batch until the last two are reached (e.g. given a tensor x</span>
<span class="sd">        of dimension (16,8,64,512) the function permute each of the 16*8 EEG signals (64 channels of 512 samples)</span>
<span class="sd">        individually).</span>
<span class="sd">        Default: False</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Nchan</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Ndim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># Check if given input is ok </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chan2shuf</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">chan2shuf</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">chan2shuf</span><span class="o">&gt;</span><span class="n">Nchan</span><span class="p">):</span>
        <span class="n">msgLog</span><span class="o">=</span><span class="s1">&#39;chan2shuf must be bigger than 1 and smaller than the number of channels in the recorded EEG. </span><span class="se">\n</span><span class="s1"> &#39;</span>
        <span class="n">msgLog</span> <span class="o">+=</span> <span class="s1">&#39;Default value is -1, which means all EEG channels are shuffled&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msgLog</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be an array or tensor with the last two dimensions [channel]*[time window]&#39;</span><span class="p">)</span>
    
    <span class="n">chan2shuf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">chan2shuf</span><span class="o">==-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">chan2shuf</span> 
    <span class="n">x2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">batch_equal</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;network&#39;</span><span class="p">:</span>
            <span class="c1"># Define or check channel map and channel networks</span>
            <span class="n">channel_map</span> <span class="p">,</span> <span class="n">networks</span> <span class="o">=</span> <span class="n">get_channel_map_and_networks</span><span class="p">(</span><span class="n">channel_map</span><span class="p">,</span> <span class="n">chan_net</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">channel_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;channel map does not match the number of channels in eeg recording&#39;</span><span class="p">)</span>
            
            <span class="c1"># get index of channels in networks</span>
            <span class="n">is_in_channel_map</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">channel_map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">networks</span><span class="p">)):</span>
                <span class="n">idx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">channel_map</span><span class="p">,</span> <span class="n">networks</span><span class="p">[</span><span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">is_in_channel_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">chan_idx</span><span class="o">=</span><span class="n">is_in_channel_map</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># randomly select a number of channels equals to chan2shuf</span>
            <span class="n">idxor_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">chan_idx</span><span class="p">)[:</span><span class="n">chan2shuf</span><span class="p">]</span>
            <span class="n">idxor_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idxor_full</span><span class="p">)</span>
            <span class="n">idx_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">chan2shuf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># shuffle according to the selected networks</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">networks</span><span class="p">)):</span>
                <span class="n">idxor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">channel_map</span><span class="p">[</span><span class="n">idxor_full</span><span class="p">],</span> <span class="n">networks</span><span class="p">[</span><span class="n">k</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#identify chans idx</span>
                <span class="n">idxor</span> <span class="o">=</span> <span class="n">idxor</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx_full</span><span class="p">[</span><span class="n">idxor</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># keep only non shuffled channels</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idxor_full</span><span class="p">[</span><span class="n">idxor</span><span class="p">])</span> <span class="c1">#get chans idx</span>
                <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span><span class="o">==</span><span class="n">idxor_full</span><span class="p">[</span><span class="n">idxor</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">idx_full</span><span class="p">[</span><span class="n">idxor</span><span class="p">]</span><span class="o">=</span><span class="n">idx</span>

            <span class="c1"># final results</span>
            <span class="n">idxor</span> <span class="o">=</span> <span class="n">idxor_full</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_full</span>   
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">idxor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">idxor_full</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">idx_full</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        
        <span class="c1"># random mode shuffle channels at random</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nchan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">chan2shuf</span><span class="p">]</span>
                <span class="n">idxor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span><span class="o">==</span><span class="n">idxor</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">Nchan</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">chan2shuf</span><span class="p">]</span>
                <span class="n">idxor</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">while</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">idxor</span><span class="p">))</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="o">!=</span><span class="s1">&#39;cpu&#39;</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">idxor</span><span class="o">=</span> <span class="n">idxor</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># apply defined shuffle</span>
        <span class="n">xtemp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">idxor</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">xtemp</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># call recursively for each dimension until last 2 are reached</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">permute_channels</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">chan2shuf</span><span class="o">=</span> <span class="n">chan2shuf</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> 
                                     <span class="n">channel_map</span><span class="o">=</span><span class="n">channel_map</span><span class="p">,</span> <span class="n">chan_net</span><span class="o">=</span><span class="n">chan_net</span><span class="p">)</span>
               
    <span class="k">return</span> <span class="n">x2</span></div>


<div class="viewcode-block" id="permutation_signal"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.permutation_signal">[docs]</a><span class="k">def</span> <span class="nf">permutation_signal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> 
                       <span class="n">segments</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                       <span class="n">seg_to_per</span><span class="p">:</span> <span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    permutation_signal permute some portion of the last dimension of the input N-D array_like x</span>
<span class="sd">    </span>
<span class="sd">    Given an input x where the last two dimension must be (EEG_channels x EEG_samples), permutation_signal </span>
<span class="sd">    divides the elements of the last dimension of x into N segments, then chooses M&lt;=N segments and shuffle it. </span>
<span class="sd">    Permutations are equally performed along each Channel of the same EEG. </span>
<span class="sd">    If batch_equal is set to False, call the function recursively along each of the (N_{1}*N_{2}...*N{-3}) </span>
<span class="sd">    dimensions of the tensor.</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    </span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        The element to shuffle. The last two dimensions must be (EEG_channel x EEG_samples), which means that the </span>
<span class="sd">        same permutation is applied to all the channels of the EEG signal.</span>
<span class="sd">    segments: int, optional</span>
<span class="sd">        The number of segments in which the last dimension of x must be divided. Must be greater than 1</span>
<span class="sd">        Default: 1</span>
<span class="sd">    seg_to_per: int, optional</span>
<span class="sd">        The number of segments to permute. Must be greater than 1 and lower than segments. -1 is the only</span>
<span class="sd">        accepted negative number and means permute all the segments.</span>
<span class="sd">        Default: -1</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same permutation to all EEG record or not. If True, permute_signal is called </span>
<span class="sd">        recursively for each dimension of the batch until the last two are reached (e.g. given a tensor x</span>
<span class="sd">        of dimension (16,8,64,512) the function permute each of the 16*8 EEG signals (64 channels of 512 samples)</span>
<span class="sd">        individually).</span>
<span class="sd">        Default: False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">segments</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;segments cannot be less than 2&#39;</span><span class="p">)</span>     
    <span class="k">if</span> <span class="n">seg_to_per</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">seg_to_per</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;seg_to_per must be bigger than 1 (put -1 to permute all segments)&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">seg_to_per</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">seg_to_per</span><span class="o">=</span><span class="n">segments</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">seg_to_per</span><span class="o">&lt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">msgError</span><span class="o">=</span><span class="s1">&#39;got a negative number of segments to permute. Only -1 to permute all segments is allowed&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msgError</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">seg_to_per</span><span class="o">&gt;</span><span class="n">segments</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;number of segment to permute is bigger than the number of segment&#39;</span><span class="p">)</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">batch_equal</span><span class="p">):</span>
        
        <span class="n">segment_len</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">segments</span>
        <span class="n">idx1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx1</span><span class="p">[:</span><span class="n">seg_to_per</span><span class="p">])</span>
        <span class="n">idx1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>
        <span class="n">idx3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx2</span><span class="o">==</span><span class="n">idx3</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span>
        <span class="n">idx1</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="o">=</span><span class="n">idx3</span>
        <span class="n">full_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">idx1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">start</span><span class="o">=</span><span class="n">segment_len</span><span class="o">*</span><span class="n">idx1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">start2</span> <span class="o">=</span> <span class="n">segment_len</span><span class="o">*</span><span class="n">k</span>
                <span class="n">newidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">segment_len</span><span class="p">)</span>
                <span class="n">full_idx</span><span class="p">[</span><span class="n">start2</span><span class="p">:</span> <span class="n">start2</span><span class="o">+</span><span class="n">segment_len</span><span class="p">]</span><span class="o">=</span> <span class="n">newidx</span>
                
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">full_idx2</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">full_idx</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">full_idx2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">full_idx</span><span class="p">]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">permutation_signal</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">segments</span><span class="o">=</span><span class="n">segments</span><span class="p">,</span> <span class="n">seg_to_per</span><span class="o">=</span><span class="n">seg_to_per</span><span class="p">,</span> <span class="n">batch_equal</span><span class="o">=</span><span class="n">batch_equal</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">x2</span></div>
    
    

<span class="c1"># --- CROP AND RESIZE ---</span>
<div class="viewcode-block" id="warp_signal"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.warp_signal">[docs]</a><span class="k">def</span> <span class="nf">warp_signal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                <span class="n">segments</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">stretch_strength</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span>
                <span class="n">squeeze_strength</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    warp_signal stretch and squeeze portion of the last dimension of the input x </span>
<span class="sd">    and resize to the original size.</span>
<span class="sd">    </span>
<span class="sd">    Given x a N-D Tensor where the last two dim are Channel x Signal, warp_signal:</span>
<span class="sd">    1) divide the last dimension of x into N segments</span>
<span class="sd">    2) select at random a subset segments</span>
<span class="sd">    3) stretch those segments according to stretch_strength</span>
<span class="sd">    4) squeeze other segments according to squeeze_strength</span>
<span class="sd">    5) resample x to the original dimension. For this part pchip interpolation </span>
<span class="sd">       with a uniform virtual grid is used</span>
<span class="sd">    If batch_equal is set to False, call the function recursively and repeat step 1 to 5 for each </span>
<span class="sd">    (N_{1}*N_{2}...*N{-3}) elements of the tensor, until the recursion gets a 2-dimensional sub-tensor.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : N-D Tensor or numpy array</span>
<span class="sd">        The array to warp. It accepts any dimensions but the last 2 must be Channel x Signal.</span>
<span class="sd">        For example, if x is 4-D, it must be in the form (N1 x N2 x Channels x Signal), where N1 and N2 are usually</span>
<span class="sd">        the batch size and channels</span>
<span class="sd">    segments : int, optional</span>
<span class="sd">        The number of segments to consider when dividing the last dimension of x.</span>
<span class="sd">        Default: 10</span>
<span class="sd">    stretch_strength : float, optional</span>
<span class="sd">        The stretch power, i.e. a multiplication factor which determines the number of samples the stretched </span>
<span class="sd">        segment must have. </span>
<span class="sd">        Default: 2.</span>
<span class="sd">    squeeze_strength : float, optional</span>
<span class="sd">        The squeeze power. The same as stretch but for the segments to squeeze</span>
<span class="sd">        Default: 0.5</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same warp to all records or not. True means faster computation but more memory</span>
<span class="sd">        consuption and less variability, False the opposite.</span>
<span class="sd">        Default: False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_warped_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>

        <span class="c1"># set segment do stretch squeeze</span>
        <span class="n">seglen</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">segments</span>
        <span class="n">seg_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="n">stretch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">seg_range</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">segments</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">squeeze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">seg_range</span><span class="p">,</span> <span class="n">stretch</span><span class="p">)</span>

        <span class="c1"># pre-allocate warped vector to avoid continuous stack call</span>
        <span class="n">Lseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">segments</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Lseg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">seg_range</span><span class="o">*</span><span class="n">seglen</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Lseg</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">seg_range</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">seglen</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Lseg</span> <span class="o">=</span> <span class="n">Lseg</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lseg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Lsegsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Lseg</span><span class="p">)</span>

        <span class="n">x_size</span><span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">warped_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Lseg</span><span class="p">[</span><span class="n">stretch</span><span class="p">]</span><span class="o">*</span><span class="n">stretch_strength</span><span class="p">))</span> <span class="o">+</span> 
                         <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Lseg</span><span class="p">[</span><span class="n">squeeze</span><span class="p">]</span><span class="o">*</span><span class="n">squeeze_strength</span><span class="p">))</span> <span class="p">)</span>
        <span class="n">x_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">warped_len</span>

        <span class="c1"># initialize warped array (i.e. the array where to allocate stretched and squeezed segments)</span>
        <span class="n">x_warped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x_size</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># iterate over segments and stretch or squeeze each segment, then allocate to x_warped</span>
        <span class="n">idx_cnt</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>

            <span class="n">piece</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">seglen</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">seglen</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stretch</span><span class="p">:</span>
                <span class="n">new_piece_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">stretch_strength</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_piece_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">squeeze_strength</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">warped_piece</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">pchip_interpolate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> 
                                                                         <span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">piece</span><span class="p">,</span> 
                                                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_piece_dim</span><span class="p">),</span> 
                                                             <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warped_piece</span> <span class="o">=</span> <span class="n">torch_pchip</span><span class="p">(</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">piece</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                           <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> 
                                            <span class="n">piece</span><span class="p">,</span> 
                                            <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_piece_dim</span><span class="p">,</span>
                                                           <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>

            <span class="n">x_warped</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx_cnt</span> <span class="p">:</span> <span class="n">idx_cnt</span><span class="o">+</span><span class="n">new_piece_dim</span><span class="p">]</span><span class="o">=</span><span class="n">warped_piece</span>
            <span class="n">idx_cnt</span> <span class="o">+=</span> <span class="n">new_piece_dim</span>
            
        <span class="c1"># resample x_warped to fit original size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_warped</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x_warped_final</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">pchip_interpolate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">warped_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">warped_len</span><span class="p">),</span> 
                                                           <span class="n">x_warped</span><span class="p">,</span> 
                                                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">warped_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> 
                                                                         <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_warped_final</span> <span class="o">=</span> <span class="n">torch_pchip</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">warped_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">warped_len</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> 
                                         <span class="n">x_warped</span><span class="p">,</span> 
                                         <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">warped_len</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
    
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Recursively call until second to last dim is reached</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_warped_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">warp_signal</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span><span class="n">segments</span><span class="p">,</span> <span class="n">stretch_strength</span><span class="p">,</span><span class="n">squeeze_strength</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">)</span>
     
    <span class="k">return</span> <span class="n">x_warped_final</span></div>


<div class="viewcode-block" id="crop_and_resize"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.crop_and_resize">[docs]</a><span class="k">def</span> <span class="nf">crop_and_resize</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s1">&#39;N-D Tensor or array&#39;</span><span class="p">,</span>
                    <span class="n">segments</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">N_cut</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    crop_and_resize crop some segments of the last dimension of the input x and resize to the original dimension.</span>
<span class="sd">    </span>
<span class="sd">    Given x a N-D Tensor where the last two dim are EEG_Channel x EEG_Signal, crop_and_resize:</span>
<span class="sd">    1) divide the last dimension of x into N segments</span>
<span class="sd">    2) select at random a subset segments</span>
<span class="sd">    3) remove the selected segments from x</span>
<span class="sd">    4) create a new cropped version of x</span>
<span class="sd">    5) resample the new cropped version to the original dimension. For this part pchip interpolation </span>
<span class="sd">       with a uniform virtual grid is used</span>
<span class="sd">    If batch_equal is set to False, call the function recursively and repeat step 1 to 5 for each </span>
<span class="sd">    (N_{1}*N_{2}...*N{-3}) elements of the tensor.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : N-D Tensor or numpy array</span>
<span class="sd">        The array to crop and resize. It accepts any dimensions but the last 2 must be EEG_Channel x EEG_Signal.</span>
<span class="sd">        For example, if x is 4-D, it must be in the form (N1 x N2 x Channels x Signal), where N1 and N2 are usually</span>
<span class="sd">        the batch size and channels</span>
<span class="sd">    segments : int, optional</span>
<span class="sd">        The number of segments to consider when dividing the last dimension of x.</span>
<span class="sd">        Default: 10</span>
<span class="sd">    N_cut : int, optional</span>
<span class="sd">        The number of segments to cut. </span>
<span class="sd">        Default: 1</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same crop to all EEG record or not. True means faster computation but more memory</span>
<span class="sd">        consuption and less variability, False the opposite</span>
<span class="sd">        Default: False</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    dim = (16,1,64,512)</span>
<span class="sd">    segments=15</span>
<span class="sd">    N_cut=6</span>
<span class="sd">    </span>
<span class="sd">    x = torch.sin(torch.linspace(0,20*math.pi, dim[-1]))</span>
<span class="sd">    zero_tensor = torch.zeros(dim)</span>
<span class="sd">    x = zero_tensor + x</span>
<span class="sd">    # x = x.numpy() #the result won&#39;t change if x is a numpy array</span>
<span class="sd">    </span>
<span class="sd">    x_crop = crop_and_resize(x, segments= segments, N_cut= N_cut, batch_equal=True)</span>
<span class="sd">    print(torch.equal(x_crop[1], x_crop[2])) # True</span>
<span class="sd">    x_crop = crop_and_resize(x, segments= segments, N_cut= N_cut, batch_equal=False)</span>
<span class="sd">    print(torch.equal(x_crop[1], x_crop[2])) # False</span>
<span class="sd">    </span>
<span class="sd">    # plot the results</span>
<span class="sd">    plt.plot(xnp[0,0,0,:])</span>
<span class="sd">    plt.show()</span>
<span class="sd">    plt.plot(x_crop[0,0,0,:])</span>
<span class="sd">    plt.plot(x_crop[2,0,0,:])</span>
<span class="sd">    plt.show()</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_crop</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">Ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">batch_equal</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">):</span>
        
        <span class="n">segment_len</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">segments</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">seg_to_rem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">segments</span><span class="p">,</span> <span class="n">N_cut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_to_rem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">segment_len</span><span class="o">*</span><span class="n">N_cut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seg_to_rem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">start</span><span class="o">=</span><span class="n">segment_len</span><span class="o">*</span><span class="p">(</span><span class="n">seg_to_rem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">segment_len</span><span class="o">*</span><span class="n">i</span>
                <span class="n">idx_to_rem</span><span class="p">[</span><span class="n">idx1</span> <span class="p">:</span> <span class="n">idx1</span><span class="o">+</span><span class="n">segment_len</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">segment_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">segment_len</span><span class="p">)</span>

            <span class="n">new_x</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_to_rem</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_crop</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">pchip_interpolate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> 
                                                   <span class="n">new_x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">seg_to_rem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">segments</span><span class="p">)[:</span><span class="n">N_cut</span><span class="p">]</span>
            <span class="n">idx_to_rem</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">segment_len</span><span class="o">*</span><span class="n">N_cut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seg_to_rem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">start</span><span class="o">=</span><span class="n">segment_len</span><span class="o">*</span><span class="p">(</span><span class="n">seg_to_rem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">segment_len</span><span class="o">*</span><span class="n">i</span>
                <span class="n">idx_to_rem</span><span class="p">[</span><span class="n">idx1</span> <span class="p">:</span> <span class="n">idx1</span><span class="o">+</span><span class="n">segment_len</span><span class="p">]</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">segment_len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">segment_len</span><span class="p">)</span>

            <span class="c1"># https://stackoverflow.com/questions/55110047/finding-non-intersection-of-two-pytorch-tensors</span>
            <span class="n">allidx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span> <span class="p">(</span><span class="n">allidx</span><span class="p">,</span> <span class="n">idx_to_rem</span><span class="p">,</span> <span class="n">idx_to_rem</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">uniques</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">uniques</span><span class="p">[</span><span class="n">counts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">new_x</span><span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">difference</span><span class="p">]</span>
            <span class="n">x_crop</span> <span class="o">=</span> <span class="n">torch_pchip</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> 
                                 <span class="n">new_x</span><span class="p">,</span> 
                                 <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_crop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crop_and_resize</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">segments</span><span class="p">,</span> <span class="n">N_cut</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">)</span>

        
    <span class="k">return</span> <span class="n">x_crop</span></div>



<span class="c1"># RE-REFERENCING</span>
<div class="viewcode-block" id="change_ref"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.change_ref">[docs]</a><span class="k">def</span> <span class="nf">change_ref</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
               <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">int</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
               <span class="n">reference</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">exclude_from_ref</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    change_ref change the reference of all EEG record in x.</span>
<span class="sd">    </span>
<span class="sd">    Given an input tensor or array x where the last two dimension must be (EEG_channels x EEG_samples),</span>
<span class="sd">    change_ref change the reference of the all the EEG records according to the modality specified.</span>
<span class="sd">    Currently, reference can be changed to:</span>
<span class="sd">    </span>
<span class="sd">    1) Channel reference (e.g. Cz). Each record of a channel is subtracted to the record of the Cz channel. </span>
<span class="sd">       Cz(t) becomes 0 for all t</span>
<span class="sd">    2) Common Average Reference (CAR). Each record is subtracted with the average of all electrodes. Currently,</span>
<span class="sd">       it doesn&#39;t cover all particular cases as this implementation is minimalist.</span>
<span class="sd">    </span>
<span class="sd">    To get a more detailed description about re-referencing, check this brief background page of the EEGlab library</span>
<span class="sd">    at the following link: https://eeglab.org/tutorials/ConceptsGuide/rereferencing_background.html</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    </span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        The element to re-reference. It can be a batch of EEGs, but the last two dimensions </span>
<span class="sd">        must be (EEG_channel x EEG_samples)</span>
<span class="sd">    mode: str or int, optional</span>
<span class="sd">        The re-reference modality. Accepted arguments:</span>
<span class="sd">            1) 0, &#39;chan&#39;, &#39;channel&#39;. Single Channel re-referencing.</span>
<span class="sd">            2) 1, &#39;avg&#39;, &#39;average&#39;, &#39;car&#39;. Common Avarage re-referencing.</span>
<span class="sd">        Default: &#39;avg&#39;</span>
<span class="sd">    reference: int, optional</span>
<span class="sd">        The reference electrode, given as an int referring to the position in the EEG_channels dimension of X</span>
<span class="sd">        (remember that this means the first dim if x is a matrix or the second to last if x is N-dim)</span>
<span class="sd">        Default: None</span>
<span class="sd">    exclude_from_ref: int or list[int]</span>
<span class="sd">        Argument designed to exclude some channels during average re-referencing. This apply for example when x</span>
<span class="sd">        has records from nose tip or ear lobe.</span>
<span class="sd">        Default: None</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be at least a 2 dim array&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">reference</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reference</span><span class="o">&gt;=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;reference index exceeds the number of channels in x&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reference</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">msgErr</span> <span class="o">=</span> <span class="s1">&#39;mode not supported. Current available modes are </span><span class="se">\&#39;</span><span class="s1">avg</span><span class="se">\&#39;</span><span class="s1">, which use the common average reference &#39;</span>
            <span class="n">msgErr</span> <span class="o">+=</span> <span class="s1">&#39;and </span><span class="se">\&#39;</span><span class="s1">Cz</span><span class="se">\&#39;</span><span class="s1">, which support original vertex reference.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msgErr</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">,</span><span class="s1">&#39;car&#39;</span><span class="p">]:</span>
            <span class="n">mode</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">]:</span>
            <span class="n">mode</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msgErr</span> <span class="o">=</span> <span class="s1">&#39;mode not supported. Current available modes are </span><span class="se">\&#39;</span><span class="s1">avg</span><span class="se">\&#39;</span><span class="s1">, which use the common average reference &#39;</span>
            <span class="n">msgErr</span> <span class="o">+=</span> <span class="s1">&#39;and </span><span class="se">\&#39;</span><span class="s1">Cz</span><span class="se">\&#39;</span><span class="s1">, which support original vertex reference.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msgErr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode must be a string. Use help() to consult all available mode&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">exclude_from_ref</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_from_ref</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">exclude_from_ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude_from_ref</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exclude_from_ref</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;exclude_from_ref must be an int or a list of int&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;exclude_from_ref indeces exceed the number of channels in x&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude_from_ref</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Ref</span><span class="o">=</span> <span class="n">x</span><span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">reference</span><span class="p">]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_from_ref</span><span class="o">+</span><span class="p">[</span><span class="n">reference</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">Ref</span><span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">reference</span><span class="p">]</span>
        <span class="n">x_new_ref</span><span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">Ref</span>
        <span class="c1">#if mode==0:</span>
        <span class="c1">#    x_new_ref[reference]= -Ref     </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_new_ref</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_new_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">change_ref</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">exclude_from_ref</span><span class="o">=</span><span class="n">exclude_from_ref</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">x_new_ref</span></div>



<div class="viewcode-block" id="masking"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.masking">[docs]</a><span class="k">def</span> <span class="nf">masking</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
            <span class="n">mask_number</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">masked_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
           <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    masking put portions of the input argument to 0.</span>
<span class="sd">    </span>
<span class="sd">    Given a N-dim tensor or a numpy array, masking put a portion of the tensor/array to 0 along the last dimension.</span>
<span class="sd">    If the tensor has more than the one dimension, the last two dimensions must be (Channel x Signal) and the function </span>
<span class="sd">    will mask each channel of the signal equally.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : N-D Tensor or numpy array</span>
<span class="sd">        The element to mask. It accepts any dimensions but the last 2 must be Channel x Signal, since the function is </span>
<span class="sd">        performed along the last dimension but equally for each channel of the signal.</span>
<span class="sd">    mask_number: int, optional</span>
<span class="sd">        The number of portion to mask. It must be a positive integer</span>
<span class="sd">        Default: 1</span>
<span class="sd">    masked_ratio: float, optional</span>
<span class="sd">        The percentage of the signal to mask. It must be a scalar in range 0&lt;maskef_ratio&lt;1.</span>
<span class="sd">        Default: 0.1</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        Whether to apply the same masking to all elements in the batch or not. Does apply only if x has more than 2 dimensions</span>
<span class="sd">        Default: False</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_number</span><span class="p">,</span><span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="n">mask_number</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mask_number must be a positive integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">masked_ratio</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">masked_ratio</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mask_ratio must be in range (0,1), i.e. all values between 0 and 1 excluded&#39;</span><span class="p">)</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_masked</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span> <span class="ow">or</span> <span class="n">batch_equal</span><span class="p">:</span> 
        
        <span class="c1"># IDENTIFY LENGTH OF MASKED PIECES</span>
        <span class="n">sample2mask</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">masked_ratio</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pieces</span><span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">mask_number</span>
        <span class="n">piece_sum</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="n">left</span><span class="o">=</span> <span class="n">sample2mask</span><span class="o">-</span><span class="n">piece_sum</span><span class="o">-</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">minval</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span> <span class="p">(</span><span class="n">left</span><span class="o">/</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.75</span><span class="p">)</span>  <span class="p">)</span>
            <span class="n">maxval</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">left</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span> <span class="p">(</span><span class="n">left</span><span class="o">/</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">1.25</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span>
            <span class="n">piece_sum</span> <span class="o">+=</span> <span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">pieces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">sample2mask</span><span class="o">-</span><span class="n">piece_sum</span>
        
        <span class="c1"># IDENTIFY POSITION OF MASKED PIECES</span>
        <span class="n">maxspace</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">sample2mask</span>
        <span class="n">spaces</span><span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">mask_number</span>
        <span class="n">space_sum</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_number</span><span class="p">):</span>
            <span class="n">left</span><span class="o">=</span> <span class="n">maxspace</span><span class="o">-</span><span class="n">space_sum</span><span class="o">-</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">spaces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span> <span class="n">left</span><span class="o">/</span><span class="p">(</span><span class="n">mask_number</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">space_sum</span> <span class="o">+=</span> <span class="n">spaces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># APPLYING MASKING</span>
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mask_number</span><span class="p">):</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">spaces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">x_masked</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">cnt</span><span class="p">:</span><span class="n">cnt</span><span class="o">+</span><span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">masking</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask_number</span><span class="o">=</span><span class="n">mask_number</span><span class="p">,</span> <span class="n">masked_ratio</span><span class="o">=</span><span class="n">masked_ratio</span><span class="p">,</span> <span class="n">batch_equal</span><span class="o">=</span><span class="n">batch_equal</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">x_masked</span></div>

<div class="viewcode-block" id="channel_dropout"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.channel_dropout">[docs]</a><span class="k">def</span> <span class="nf">channel_dropout</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;N-D Tensor of numpy Array&quot;</span><span class="p">,</span>
                    <span class="n">Nchan</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    channel_dropout put to 0 a given (or random) amount of channels selected at random.</span>
<span class="sd">    </span>
<span class="sd">    Given a N-D tensor or numpy array, where the last two dimensions refers to Channels x Samples,</span>
<span class="sd">    channel_dropout will choose a random a subset of Channels based on Nchan and put them to 0.</span>
<span class="sd">    </span>
<span class="sd">    If batch_equal is set to True, the function will be called recursively producing a different</span>
<span class="sd">    augmentation for each EEG in the tensor.</span>
<span class="sd">    </span>
<span class="sd">    Paramters</span>
<span class="sd">    ---------</span>
<span class="sd">    x: N-D Tensor or numpy array</span>
<span class="sd">        Array or Tensor to augment. Last two dimensions must be Channels x Samples</span>
<span class="sd">    Nchan: int, optional</span>
<span class="sd">        Number of channels to drop. If not given, the number of channels is chosen at random in the </span>
<span class="sd">        interval [1, (Channel_total // 4) +1 ]</span>
<span class="sd">        Defult: None</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        whether to apply the same channel drop to all EEG records or not.</span>
<span class="sd">        Default: True</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Ndim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_drop</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Nchan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Nchan</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Nchan</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Nchan can</span><span class="se">\&#39;</span><span class="s1">t be higher than the actual number&#39;</span> 
                                 <span class="s1">&#39; of channels in the given EEG&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Nchan</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Nchan</span><span class="p">)</span>
        <span class="n">drop_chan</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])[:</span><span class="n">Nchan</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">drop_chan</span><span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">drop_chan</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">x_drop</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">drop_chan</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_drop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_dropout</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Nchan</span><span class="o">=</span><span class="n">Nchan</span><span class="p">,</span> <span class="n">batch_equal</span><span class="o">=</span><span class="n">batch_equal</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">x_drop</span></div>


<div class="viewcode-block" id="add_eeg_artifact"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.add_eeg_artifact">[docs]</a><span class="k">def</span> <span class="nf">add_eeg_artifact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                     <span class="n">Fs</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">artifact</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">amplitude</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">line_at_60Hz</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">lost_time</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">drift_slope</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">batch_equal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span> <span class="kc">False</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    add_eeg_artifact add one common artifacts of EEG signals.</span>
<span class="sd">    </span>
<span class="sd">    Given a N-dim tensor or a numpy array, add_eeg_artifact add one of the artifact listed in</span>
<span class="sd">    -- Fickling et al., (2019) Good data? The EEG Quality Index for Automated Assessment of Signal Quality --</span>
<span class="sd">    along the last dimension of the input element. Supported artifacts are:</span>
<span class="sd">    </span>
<span class="sd">        1) white: simple white noise</span>
<span class="sd">        2) line: noise at 50 Hz or 60 Hz</span>
<span class="sd">        3) eye: noise in range [1, 3] Hz</span>
<span class="sd">        4) muscle: noise in range [20, 60] Hz</span>
<span class="sd">        5) drift: straight line with non-zero slope</span>
<span class="sd">        6) lost: cancellation of one portion of the signal</span>
<span class="sd">    </span>
<span class="sd">    Line, eye and muscle artifact are generated with the add_band_noise function. </span>
<span class="sd">    Lost artifact is generated with the masking function.</span>
<span class="sd">    White and drift are generated inside this function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : N-D Tensor or numpy array</span>
<span class="sd">        The element to add the artifact. It accepts any dimensions but the last 2 must be Channel x Signal, </span>
<span class="sd">        since the function is performed along the last dimension but equally for each channel of the signal.</span>
<span class="sd">    Fs: float</span>
<span class="sd">        The sampling rate of the signal in Hz</span>
<span class="sd">    amplitude: float, optional</span>
<span class="sd">        The amplitude of the noise to add. If not given, amplitude=std(x)</span>
<span class="sd">        Default: None</span>
<span class="sd">    line_at_60Hz: bool, optional</span>
<span class="sd">        Whether to apply the line artifact at 60Hz (True) or 50Hz (False).</span>
<span class="sd">        Default: True</span>
<span class="sd">    lost_time: float, optional</span>
<span class="sd">        The amount of time the signal is canceled. Must be given in seconds. Internally masking function is called</span>
<span class="sd">        by converting the given time to the percentage of masked signal with the function</span>
<span class="sd">        (Fs*lost_time)/x.shape[-1]. Alternatively, to convert the percentage of the signal masked to the amount of </span>
<span class="sd">        time is masked, just revert the formula, so lost_time= (masking_percentage * x.shape[-1]) / Fs.</span>
<span class="sd">        If None is given, 20% of the signal is masked</span>
<span class="sd">        Default: None</span>
<span class="sd">    drift_slope: float, optional</span>
<span class="sd">        The difference between to consecutive points of the straight line to add. If None is given, slope is</span>
<span class="sd">        calculated with the amplitude parameter as drift_slope = amplitude/x.shape[-1]. If also amplitude is not</span>
<span class="sd">        given drift_slope = std(x)/x.shape[-1]</span>
<span class="sd">    batch_equal: bool, optional</span>
<span class="sd">        Whether to apply the same masking to all elements in the batch or not. Does apply only if x has more than 2 dimensions</span>
<span class="sd">        Default: False</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">was_random</span><span class="o">=</span><span class="kc">False</span> <span class="c1">#just for recursive calls</span>
    <span class="k">if</span> <span class="n">artifact</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">artifact</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">,</span><span class="s1">&#39;lost&#39;</span><span class="p">,</span><span class="s1">&#39;drift&#39;</span> <span class="p">,</span><span class="s1">&#39;eye&#39;</span><span class="p">,</span> <span class="s1">&#39;muscle&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;EEG artifact not supported. Accepted any of </span><span class="se">\&#39;</span><span class="s1">line</span><span class="se">\&#39;</span><span class="s1">,</span><span class="se">\&#39;</span><span class="s1">lost</span><span class="se">\&#39;</span><span class="s1">,</span><span class="se">\&#39;</span><span class="s1">drift</span><span class="se">\&#39;</span><span class="s1">,</span><span class="se">\&#39;</span><span class="s1">eye</span><span class="se">\&#39;</span><span class="s1">,</span><span class="se">\&#39;</span><span class="s1">muscle</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">was_random</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">artifact</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;line&#39;</span><span class="p">,</span><span class="s1">&#39;lost&#39;</span><span class="p">,</span><span class="s1">&#39;drift&#39;</span> <span class="p">,</span><span class="s1">&#39;eye&#39;</span><span class="p">,</span> <span class="s1">&#39;muscle&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">amplitude</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">amplitude</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="n">amplitude</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">]</span> <span class="k">if</span> <span class="n">amplitude</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">amplitude</span><span class="p">,</span> <span class="o">-</span><span class="n">amplitude</span><span class="p">]</span>
    
    <span class="n">Ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">batch_equal</span> <span class="ow">or</span> <span class="n">Ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span>
            <span class="n">freq</span><span class="o">=</span> <span class="mi">60</span> <span class="k">if</span> <span class="n">line_at_60Hz</span> <span class="k">else</span> <span class="mi">50</span>
            <span class="n">x_noise</span><span class="p">,</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">add_band_noise</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">get_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;eye&#39;</span><span class="p">:</span>
            <span class="n">x_noise</span> <span class="o">=</span> <span class="n">add_band_noise</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;muscle&#39;</span><span class="p">:</span>
            <span class="n">x_noise</span> <span class="o">=</span> <span class="n">add_band_noise</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">60</span><span class="p">),</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;lost&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lost_time</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">x_noise</span> <span class="o">=</span> <span class="n">masking</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_noise</span> <span class="o">=</span> <span class="n">masking</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">Fs</span><span class="o">*</span><span class="n">lost_time</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">elif</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">amplitude</span> <span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">*=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span> <span class="k">if</span> <span class="n">amplitude</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
                    <span class="n">noise</span> <span class="o">*=</span> <span class="n">G</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span> <span class="k">if</span> <span class="n">amplitude</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
                    <span class="n">noise</span> <span class="o">*=</span> <span class="n">G</span>
            <span class="n">x_noise</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">noise</span> 
                    
        <span class="k">elif</span> <span class="n">artifact</span> <span class="o">==</span> <span class="s1">&#39;drift&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">drift_slope</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">drift_slope</span>
                <span class="k">elif</span> <span class="n">amplitude</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">drift_slope</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">*</span><span class="n">drift_slope</span>
                <span class="k">elif</span> <span class="n">amplitude</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">x_noise</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">noise</span>
     
    <span class="k">else</span><span class="p">:</span>
        <span class="n">artifact_arg</span><span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">was_random</span> <span class="k">else</span> <span class="n">artifact</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x_noise</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_eeg_artifact</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">artifact_arg</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">line_at_60Hz</span><span class="p">,</span> <span class="n">lost_time</span><span class="p">,</span>
                                          <span class="n">drift_slope</span><span class="p">,</span> <span class="n">batch_equal</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">x_noise</span></div>


<span class="c1"># -----------------------</span>
<span class="c1"># AUGMENTATION CLASSES</span>
<span class="c1"># -----------------------</span>
<div class="viewcode-block" id="StaticSingleAug"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.StaticSingleAug">[docs]</a><span class="k">class</span> <span class="nc">StaticSingleAug</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    StaticSingleAug is a class designed to perform a single data augmentation where the optional arguments</span>
<span class="sd">    are previously set and given during initialization. No random choice of the arguments is performed. The </span>
<span class="sd">    class accepts multiple set of optional arguments. In this case they are called individually at each class</span>
<span class="sd">    call, in a sequential manner. This means that the first call use the first set of arguments, the second </span>
<span class="sd">    will use the second set of arguments, and so on. When the last set is used, the class will restart from the</span>
<span class="sd">    first set of arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">augmentation</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        augmentation: function</span>
<span class="sd">            The augmentation function to apply. It can be a custom function, but the first </span>
<span class="sd">            argument must be the element to augment</span>
<span class="sd">        arguments: list, dict, list[list or dict], optional</span>
<span class="sd">            The arguments to give to the augmentation function. It can be:</span>
<span class="sd">                1) None. In this case the default parameters of the function are used. Remember that if there are</span>
<span class="sd">                   other non optional arguments, the call will throw an error.</span>
<span class="sd">                2) a simple list. In this case the function is called with the sintax &quot;augmentation(x, *arguments)&quot;</span>
<span class="sd">                3) a simple dict. In this case the function is called with the sintax &quot;augmentation(x, **arguments)&quot;</span>
<span class="sd">                4) a list of dict or list. This is a particular case where multiple combination of arguments are given.</span>
<span class="sd">                   Each element of the list must be a list or a dict with the specific argument combination. Every time</span>
<span class="sd">                   the class is called, one of the given combination is used to perform the data augmentation. The list</span>
<span class="sd">                   is followed sequentially with repetion, meaning that the first call use the first set of arguments of the </span>
<span class="sd">                   list, the second the second set of arguments, and so on. When the last element of the list is used, the </span>
<span class="sd">                   function will restart scrolling the given list</span>
<span class="sd">            Default: None       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">augmentation</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="n">augmentation</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;augmentation must be a function to call&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="o">=</span><span class="n">augmentation</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxcounter</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipleStaticArguments</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="n">arguments</span> <span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arguments</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">multipleStaticArguments</span><span class="o">=</span><span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxcounter</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
        
<div class="viewcode-block" id="StaticSingleAug.PerformAugmentation"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.StaticSingleAug.PerformAugmentation">[docs]</a>    <span class="k">def</span> <span class="nf">PerformAugmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipleStaticArguments</span><span class="p">:</span>
            <span class="n">argument</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">Xaug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Xaug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">argument</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxcounter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">=</span><span class="mi">0</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">Xaug</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">Xaug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Xaug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Xaug</span></div>
        
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PerformAugmentation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>
        
        
        
<div class="viewcode-block" id="DynamicSingleAug"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.DynamicSingleAug">[docs]</a><span class="k">class</span> <span class="nc">DynamicSingleAug</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    DynamicSingleAug is a class designed to perform a single data augmentation where the optional arguments</span>
<span class="sd">    are chosen at random from a given discrete set or a given range. Random choice of the arguments is performed</span>
<span class="sd">    at each call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">augmentation</span><span class="p">,</span> 
                 <span class="n">discrete_arg</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">range_arg</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">range_type</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        At least one of discrete_arg or range_arg arguments must be given, otherwise simply use a StaticSingleAug</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        augmentation: function</span>
<span class="sd">            The augmentation function to apply. It can be a custom function, but the first </span>
<span class="sd">            argument must be the element to augment</span>
<span class="sd">        discrete_arg: dict, optional</span>
<span class="sd">            A dictionary specifying arguments whose value must be chosen within a discrete set. The dict must have:</span>
<span class="sd">                - Keys as string with the name of one of the optional arguments</span>
<span class="sd">                - Values as lists of elements to be randomly chosen. Single elements are accepted if a specific </span>
<span class="sd">                  value for an argument needs to be set. In this case it&#39;s not mandatory to give it as list, as </span>
<span class="sd">                  automatic conversion will be performed.</span>
<span class="sd">            Default: None</span>
<span class="sd">        range_arg: dict, optional</span>
<span class="sd">            A dictionary specifying arguments whose value must be chosen within a continuous range. The dict must have:</span>
<span class="sd">                - Keys as string with the name of one of the optional arguments</span>
<span class="sd">                - Values as two element lists specifying the range of values where to randomly select the argument value. </span>
<span class="sd">            Default: None</span>
<span class="sd">        range_type: dict or list, optional</span>
<span class="sd">            A dictionary or a list specifying if values in range_arg must be given to the augmentation function as integers:</span>
<span class="sd">            If given as a dict, keys must be the same as the one of range_arg (no more or less, the same). If given as a list,</span>
<span class="sd">            the length must be the same of range_arg. In particular:</span>
<span class="sd">                1) if range_type is a dict. </span>
<span class="sd">                    - Keys must be the ones in range_arg</span>
<span class="sd">                    - Values must be single element specifying if the argument must be an integer. In this case, use a boolean</span>
<span class="sd">                      True or a string &#39;int&#39; to specify if the argument must be converted to an int.</span>
<span class="sd">                2) if range_arg is a list.</span>
<span class="sd">                    - Values must be set as the values in the dict. The order is the one used when iterating along the</span>
<span class="sd">                      range_arg dict</span>
<span class="sd">                3) if None is given, a list of True with length equal to range_arg is automatically created, since int</span>
<span class="sd">                   arguments are more compatible with float ones.</span>
<span class="sd">            Default: None     </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># set augmentation function</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">augmentation</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="n">augmentation</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;augmentation must be a function to call&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="o">=</span><span class="n">augmentation</span>
        
        <span class="c1"># get function argument name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argnames</span><span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">augmentation</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="c1"># check if given discrete_arg keys are actually augmentation arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">if</span> <span class="n">discrete_arg</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">discrete_arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argnames</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">discrete_arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="o">=</span><span class="n">discrete_arg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;keys of discrete_arg argument must be the argument of the augmentation fun&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;discrete_arg must be a dictionary&#39;</span><span class="p">)</span>
        
        <span class="c1"># check if given range_arg keys are actually augmentation arguments </span>
        <span class="c1"># also check if values are two element list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">if</span> <span class="n">range_arg</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">argnames</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_arg</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_arg</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">=</span><span class="n">range_arg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;range_arg values must be a len 2 list with min and max range&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;keys of range_arg argument must be the argument of the augmentation fun&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_arg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">range_arg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">list</span><span class="p">)):</span>
                        <span class="n">range_arg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">range_arg</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;range_arg must be a dictionary&#39;</span><span class="p">)</span>
        
        <span class="c1"># check if range_types keys are the same as range_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">if</span> <span class="n">range_type</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_type</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">range_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">range_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="o">=</span><span class="n">range_type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;keys of range_type must be the same as range_arg&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_type</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="o">=</span><span class="n">range_type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;range_type must have the same length as range_args&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;discrete_arg must be a dictionary or a list&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">is_range_type_dict</span><span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">given_arg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">given_arg</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">!=</span><span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        
    
<div class="viewcode-block" id="DynamicSingleAug.PerformAugmentation"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.DynamicSingleAug.PerformAugmentation">[docs]</a>    <span class="k">def</span> <span class="nf">PerformAugmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>    
        <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_arg</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span> 
                    <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_arg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># counter if range_type is a list, it&#39;s a sort of enumerate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_arg</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_range_type_dict</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
                        <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_type</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
                        <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="n">Xaug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmentation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xaug</span></div>
        
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PerformAugmentation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="SequentialAug"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.SequentialAug">[docs]</a><span class="k">class</span> <span class="nc">SequentialAug</span><span class="p">():</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">augmentations</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="o">=</span><span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">augmentations</span><span class="p">]</span>
     
<div class="viewcode-block" id="SequentialAug.PerformAugmentation"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Augmentation.SequentialAug.PerformAugmentation">[docs]</a>    <span class="k">def</span> <span class="nf">PerformAugmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span> 
        
        <span class="n">Xaugs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">X</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="p">)):</span>
            <span class="n">Xaugs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">Xaugs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xaugs</span></div>
            
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PerformAugmentation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<span class="k">class</span> <span class="nc">RandomAug</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RandomAug perform a random augmentation from a list of arguments.</span>
<span class="sd">    Class must be initialized giving a sequence </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">augmentations</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">augs</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">augmentations</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="p">)</span>
     
    <span class="k">def</span> <span class="nf">PerformAugmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span> 

        <span class="n">idx</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xaugs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augs</span><span class="p">[</span><span class="n">idx</span><span class="p">](</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xaugs</span>
            
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PerformAugmentation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, MedMax Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>