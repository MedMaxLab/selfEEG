<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>selfeeg.Dataload &mdash; SelfEEG 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SelfEEG
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SelfEEG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">selfeeg.Dataload</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for selfeeg.Dataload</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">Sampler</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">subarray_closest_sum</span><span class="p">,</span> <span class="n">get_subarray_closest_sum</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;GetEEGPartitionNumber&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;GetEEGSplitTable&#39;</span><span class="p">,</span> <span class="s1">&#39;GetEEGSplitTableKfold&#39;</span><span class="p">,</span>
           <span class="s1">&#39;EEGDataset&#39;</span><span class="p">,</span> <span class="s1">&#39;EEGsampler&#39;</span><span class="p">]</span>

<span class="c1"># TO DO: ADD parallel loop in get EEG Partition Number</span>

<div class="viewcode-block" id="GetEEGPartitionNumber"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Dataload.GetEEGPartitionNumber">[docs]</a><span class="k">def</span> <span class="nf">GetEEGPartitionNumber</span><span class="p">(</span><span class="n">EEGpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                          <span class="n">freq</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">float</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> 
                          <span class="n">window</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">float</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                          <span class="n">overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.10</span><span class="p">,</span>
                          <span class="n">includePartial</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span>
                          <span class="n">load_function</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">optional_load_fun_args</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">transform_function</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">optional_transform_fun_args</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">keep_zero_sample</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GetEEGPartitionNumber(EEGpath, freq, window, overlap=0)</span>
<span class="sd">    Find the number of unique partitions from EEG signals stored inside a given directory.</span>
<span class="sd">    Some default parameters are designed to work with the &#39;auto-BIDS&#39; library. For more info,</span>
<span class="sd">    See: Link</span>
<span class="sd">    </span>
<span class="sd">    Return a Pandas DataFrame with the exact number of samples which can be extracted from each </span>
<span class="sd">    EEG file in the EEGpath directory.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    EEGpath : string </span>
<span class="sd">        Directory with all EEG files. If the last element of the string is not &quot;/&quot;, the character will</span>
<span class="sd">        be added automatically</span>
<span class="sd">    freq : int or float, optional </span>
<span class="sd">        EEG sampling rate. Must be the same for all EEG files. </span>
<span class="sd">        Default: 250</span>
<span class="sd">    window : int or float, optional</span>
<span class="sd">        Time window length in seconds.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    overlap : float, optional </span>
<span class="sd">        Same EEG recording overlap percentage. Must be in the interval [0,1)</span>
<span class="sd">        Default: 0.10</span>
<span class="sd">    includePartial : bool, optional</span>
<span class="sd">        Count also final EEG partitions at least half of the time windows filled with EEG recording</span>
<span class="sd">        Default: True</span>
<span class="sd">    file_format : str or list[str], optional</span>
<span class="sd">        A string used to detect a set of specific EEG files inside the give EEGpath. It is directly put after </span>
<span class="sd">        EEGpath during call of the glob.glob() method. Therefore, it can contain shell-style wildcards (see glob.glob()</span>
<span class="sd">        help for more info). This parameter might be helpful if you have other files other than the EEGs in your </span>
<span class="sd">        directory.</span>
<span class="sd">        Alternatively, you can provide a list of strings to cast multiple glob.glob() searches. This might be useful if</span>
<span class="sd">        you want to combine multiple identification criteria (e.g. specific file extensions, specific file names, etc.)</span>
<span class="sd">        Default: &#39;*&#39;</span>
<span class="sd">    load_function : &#39;function&#39;, optional</span>
<span class="sd">        A custom EEG file loading function. It will be used instead of the default: </span>
<span class="sd">        loadmat(ii, simplify_cells=True)[&#39;DATA_STRUCT&#39;][&#39;data&#39;] (for files preprocessed with the AUTO-BIDS library)</span>
<span class="sd">        The function must take only one required argument, which is the full path to the EEG file </span>
<span class="sd">        (e.g. the function will be called in this way: load_function(fullpath, optional_arguments) )</span>
<span class="sd">        Default: None</span>
<span class="sd">    optional_load_fun_args: list or dict, optional</span>
<span class="sd">        Optional arguments to give to the custom loading function. Can be a list or a dict.</span>
<span class="sd">        Default: None</span>
<span class="sd">    transform_function : &#39;function&#39;, optional</span>
<span class="sd">        A custom transformation to be applied after the EEG is loaded. Might be useful if there are portion of </span>
<span class="sd">        the signal to cut. </span>
<span class="sd">        The function must take only one required argument, which is the EEG file to transform</span>
<span class="sd">        (e.g. the function will be called in this way: transform_function(EEG, optional_arguments) )</span>
<span class="sd">        Default: None</span>
<span class="sd">    optional_transform_fun_args: list or dict, optional</span>
<span class="sd">        Optional arguments to give to the EEG transformation function. Can be a list or a dict.</span>
<span class="sd">        Default: None</span>
<span class="sd">    keep_zero_sample : bool, optional</span>
<span class="sd">        Whether to preserve Dataframe rows where the number of samples to extract is equal to zero.</span>
<span class="sd">    save : bool, optional</span>
<span class="sd">        Save the resulted DataFrame as a .csv file </span>
<span class="sd">    save_path: str, optional</span>
<span class="sd">        A custom path to be used instead of the current working directory. It&#39;s the string given to the </span>
<span class="sd">        pandas.DataFrame.to_csv() method.</span>
<span class="sd">        Default: None</span>
<span class="sd">    verbose: bool, optional</span>
<span class="sd">        whether to print or not some information during function excecution. Useful to keep track</span>
<span class="sd">                </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lenEEG : DataFrame</span>
<span class="sd">        Three columns Pandas DataFrame. </span>
<span class="sd">        The first column has the full path to the EEG file, the second the file name, </span>
<span class="sd">        the third its number of partitions.</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    freq*window must give an integer with the number of samples</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check Inputs</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">overlap</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;overlap must be a number in the interval [0,1)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the EEG sampling rate cannot be negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the time window cannot be negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">freq</span><span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">freq</span><span class="o">*</span><span class="n">window</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;freq*window must give an integer number &quot;</span><span class="p">)</span>
        
    <span class="c1"># Extract all files from directory</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_format</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">EEGpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="n">EEGfiles</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">EEGpath</span> <span class="o">+</span> <span class="n">file_format</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EEGfiles</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">EEGpath</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_format</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">EEGpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="n">EEGfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">eegpath</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">file_format</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EEGfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">eegpath</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">file_format</span><span class="p">]</span>
            <span class="n">EEGfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">EEGfiles</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;file_format must be a string or an iterable (e.g. list) of strings&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;didn</span><span class="se">\&#39;</span><span class="s1">t found any with the given format&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
        
                
               
    <span class="n">EEGfiles</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)</span>
    <span class="n">NumFiles</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)</span>

    <span class="c1"># Create Table</span>
    <span class="n">EEGlen</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">WindSample</span><span class="o">=</span><span class="n">freq</span><span class="o">*</span><span class="n">window</span>
    <span class="n">overlapInt</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">WindSample</span><span class="o">*</span><span class="n">overlap</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span><span class="p">(</span><span class="n">verbose</span><span class="p">),</span> 
                   <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;extracting EEG samples&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; batch&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            
            <span class="c1"># load file, if custom function is provided use it to load data according </span>
            <span class="c1"># to possible optional arguments</span>
            <span class="k">if</span> <span class="n">load_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>         
                <span class="n">EEG</span><span class="o">=</span><span class="n">loadmat</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">simplify_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;DATA_STRUCT&#39;</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_load_fun_args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="n">load_function</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="o">*</span><span class="n">optional_load_fun_args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_load_fun_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="n">load_function</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="o">**</span><span class="n">optional_load_fun_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="n">load_function</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    
            <span class="c1"># transform loaded file if custom function is provided</span>
            <span class="c1"># and call function according to possible optional arguments</span>
            <span class="k">if</span> <span class="n">transform_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_transform_fun_args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">EEG</span><span class="p">,</span> <span class="o">*</span><span class="n">optional_transform_fun_args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_transform_fun_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">EEG</span><span class="p">,</span> <span class="o">**</span><span class="n">optional_transform_fun_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">EEG</span><span class="o">=</span> <span class="n">transform_function</span><span class="p">(</span><span class="n">EEG</span><span class="p">)</span>
    
            <span class="n">M</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">EEG</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">N_Partial</span><span class="o">=</span><span class="n">EEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">WindSample</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L</span><span class="o">=</span><span class="n">EEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">N</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">overlapInt</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="n">WindSample</span><span class="o">-</span><span class="n">overlapInt</span><span class="p">)</span>
                <span class="c1">#R=L-WindSample*N+overlapInt*(N-1)</span>
                <span class="c1">#N_Partial=N+(R+overlapInt)/WindSample</span>
                <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="n">overlapInt</span><span class="o">-</span><span class="n">WindSample</span><span class="p">)</span><span class="o">*</span><span class="n">N</span>
                <span class="n">N_Partial</span><span class="o">=</span><span class="n">N</span><span class="o">+</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">)</span><span class="o">/</span><span class="n">WindSample</span>
            
            <span class="k">if</span> <span class="n">includePartial</span><span class="p">:</span>
                <span class="n">N_EEG</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">N_Partial</span><span class="p">)</span> <span class="k">if</span> <span class="n">N_Partial</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N_EEG</span><span class="o">=</span><span class="n">N</span>
    
            <span class="c1"># check for extra dimension (file with multiple trials)</span>
            <span class="k">if</span> <span class="n">M</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s1">&#39;Loaded a file with multiple EEGs (&#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-D array).&#39;</span>
                               <span class="s1">&#39; Found number of sample will be multiplied by the size of each &#39;</span>
                               <span class="s1">&#39;extra dimension. Note that this may create problems to the &#39;</span>
                               <span class="s1">&#39;__getitem()__ method in the custom EEGDataset class&#39;</span><span class="p">),</span> <span class="ne">Warning</span><span class="p">)</span>
                <span class="n">N_EEG</span><span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">EEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                
            <span class="n">EEGlen</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">N_EEG</span><span class="p">])</span>
    
    <span class="k">del</span> <span class="n">EEG</span>
    <span class="n">EEGlen</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">EEGlen</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;full_path&#39;</span><span class="p">,</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span><span class="s1">&#39;N_samples&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">keep_zero_sample</span><span class="p">):</span>
        <span class="n">EEGlen</span> <span class="o">=</span> <span class="n">EEGlen</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">EEGlen</span><span class="p">[</span><span class="n">EEGlen</span><span class="o">.</span><span class="n">N_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">EEGlen</span> <span class="o">=</span> <span class="n">EEGlen</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span> <span class="s1">&#39;index&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">EEGlen</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">condition</span><span class="o">=</span><span class="kc">True</span>
                <span class="n">cnt</span><span class="o">=-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="n">condition</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">cnt</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGPartitionNumber.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGPartitionNumber_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">EEGlen</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failed to save file. Function output will be returned but not saved.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;window&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;sampling rate&#39;</span><span class="p">,</span> <span class="s1">&#39;dataset length&#39;</span>
        <span class="n">NN</span><span class="o">=</span> <span class="n">EEGlen</span><span class="p">[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Concluded extraction of repository length with the following specific: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s1">15</span><span class="si">}</span><span class="s1"> ==&gt; </span><span class="si">{</span><span class="n">window</span><span class="si">:</span><span class="s1">5d</span><span class="si">}</span><span class="s1"> s&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">o</span><span class="si">:</span><span class="s1">15</span><span class="si">}</span><span class="s1"> ==&gt; </span><span class="si">{</span><span class="n">overlap</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s1">5.0f</span><span class="si">}</span><span class="s1"> %&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">15</span><span class="si">}</span><span class="s1"> ==&gt; </span><span class="si">{</span><span class="n">freq</span><span class="si">:</span><span class="s1">5d</span><span class="si">}</span><span class="s1"> Hz&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">d</span><span class="si">:</span><span class="s1">15</span><span class="si">}</span><span class="s1"> ==&gt; </span><span class="si">{</span><span class="n">NN</span><span class="si">:</span><span class="s1">8d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">EEGlen</span></div>


<div class="viewcode-block" id="GetEEGSplitTable"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Dataload.GetEEGSplitTable">[docs]</a><span class="k">def</span> <span class="nf">GetEEGSplitTable</span><span class="p">(</span><span class="n">partition_table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                     <span class="n">test_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">val_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">test_split_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">int</span> <span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">val_split_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="n">exclude_data_id</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">test_data_id</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">val_data_id</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">val_ratio_on_all_data</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">stratified</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">labels</span><span class="p">:</span> <span class="s1">&#39;array like&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">dataset_id_extractor</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">subject_id_extractor</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">split_tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                     <span class="n">perseverance</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                     <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;   </span>
<span class="sd">    GetEEGSplitTable create a table defining the files to use for train, validation and test of the models</span>
<span class="sd">    </span>
<span class="sd">    Return a Pandas DataFrame defining which file should be included in the training, validation or test set</span>
<span class="sd">    </span>
<span class="sd">    Split is done in the following way:</span>
<span class="sd">    Dataset --&gt; Train / Test </span>
<span class="sd">                Train --&gt; Train / Validation</span>
<span class="sd">    If specific ID are given, the split is done using them ignoring split ratio, otherwise split is done randomly</span>
<span class="sd">    using the given ratio. Keep in mind that Test or Validation can be empty, if for example you want to split </span>
<span class="sd">    the dataset only in two subsets.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partition_table: pd.Dataframe, optional</span>
<span class="sd">        A two columns dataframe where:</span>
<span class="sd">            1-the first column has name &#39;file_name&#39; and contain all the file names</span>
<span class="sd">            2-the second column has name &#39;N_samples&#39; and has the number of samples which can be extracted from the file</span>
<span class="sd">        This table can be automatically created with a custom setting with the provided function GetEEGPartitionNumber()</span>
<span class="sd">        Default: None</span>
<span class="sd">    test_ratio: float, optional</span>
<span class="sd">        The percentage of data with respect to the whole number of samples (partitions) of the dataset to be included </span>
<span class="sd">        in the test set. Must be a number in [0,1]. 0 means that the test split is skipped if test_data_id isn&#39;t given</span>
<span class="sd">        Default: None</span>
<span class="sd">    val_ratio: float, optional</span>
<span class="sd">        The percentage of data with respect to the whole number of samples (partitions) of the dataset or the remaining </span>
<span class="sd">        ones after test split (see val_ratio_on_all_data argument) to be included in the validation set. </span>
<span class="sd">        Must be a number in [0,1]. 0 means that the validation split is skipped if val_data_id isn&#39;t given</span>
<span class="sd">        Default: None</span>
<span class="sd">    test_split_mode: int or str, optional</span>
<span class="sd">        The type of split to perform in the step not_excluded_data --&gt; train / test sets. It can be one of the following:</span>
<span class="sd">            1) any of [0, &#39;d&#39;, &#39;set&#39;, &#39;dataset&#39;] = split will be performed using dataset ids, i.e. all files of the same</span>
<span class="sd">                dataset will be put in the same split set</span>
<span class="sd">            2) any of [1, &#39;s&#39;, &#39;subj&#39;, &#39;subject&#39;] = split will be performed using subjects ids, i.e. all files of the same</span>
<span class="sd">                subjects will be put in the same split set</span>
<span class="sd">            3) any of [2, &#39;file&#39;, &#39;record&#39;] = split will be performed looking at single files</span>
<span class="sd">        Default: 2</span>
<span class="sd">    val_split_mode: int or str, optional</span>
<span class="sd">        The type of split to perform in the step train --&gt; train / validation sets. Input allowed are the same as in</span>
<span class="sd">        test_split_mode.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    exclude_data_id  : list or dict, optional </span>
<span class="sd">        Dataset ID to be excluded. It can be:</span>
<span class="sd">            1) a list with all dataset ids to exclude</span>
<span class="sd">            2) a dictionary where keys are the dataset ids and values its relative subject ids. If a key is store with </span>
<span class="sd">                None as a value, then all the files from that dataset will be included</span>
<span class="sd">        Note1: To work, the function must be able to identify the dataset or subject IDs from the file name in order to check</span>
<span class="sd">            if it is in the list/dict. Custom extraction function can be given as arguments; however, if nothing is given, </span>
<span class="sd">            the function will try to extract IDs considering that file names are in the format a_b_c_d.extension </span>
<span class="sd">            (the output of the AUTO-BIDS library), where &quot;a&quot; is an integer with the dataset ID and &quot;b&quot; an integer </span>
<span class="sd">            with the subject ID. If this fail, all files will be considered from the same datasets (id=0), and each file from a </span>
<span class="sd">            different subject (id from 0 to N-1).</span>
<span class="sd">        Note2: if the input argument is not a list or a dict, it will be automatically converted to a list</span>
<span class="sd">        Default: None</span>
<span class="sd">    test_data_id: list or dict, optional </span>
<span class="sd">        Same as exclude_data_id but for the test split</span>
<span class="sd">        Defaul: None</span>
<span class="sd">    val_data_id: list or dict, optional  </span>
<span class="sd">        Same as exclude_data_id but for validation split</span>
<span class="sd">        Default: None</span>
<span class="sd">    val_ratio_on_all_data: bool, optional</span>
<span class="sd">        Whether to calculate the validation split ratio only on the training set size (False) or on the entire considered</span>
<span class="sd">        dataset (True), i.e. the size of all files except for the ones excluded</span>
<span class="sd">        files not excluded  placed in the test set.</span>
<span class="sd">        Default: True</span>
<span class="sd">    stratified: bool, optional</span>
<span class="sd">        Whether to apply stratification to the split or not. Might be used for fine-tuning split (the only phase where labels</span>
<span class="sd">        are involved). Stratification will preserve, if possible, the label&#39;s ratio on the training/validation/test sets.</span>
<span class="sd">        Works only when each file has an unique label, which must be given in input.</span>
<span class="sd">        Default: False</span>
<span class="sd">    labels: list, array like, optional</span>
<span class="sd">        A list or array like objects with the label of each file listed in the partition table. </span>
<span class="sd">        Must be given if stratification is set to True</span>
<span class="sd">        Indeces of labels must match row indeces in the partition table, i.e. label1 --&gt; row1, label2 --&gt; row2.</span>
<span class="sd">        Default: None</span>
<span class="sd">    dataset_id_extractor: function, optional</span>
<span class="sd">        A custom function to be used to extract the dataset ID from file the file name. It must accept only one argument,</span>
<span class="sd">        which is the file name</span>
<span class="sd">        Default: None</span>
<span class="sd">    subject_id_extractor: function, optional</span>
<span class="sd">        A custom function to be used to extract the subject ID from file the file name. It must accept only one argument,</span>
<span class="sd">        which is the file name</span>
<span class="sd">        Default: None</span>
<span class="sd">    split_tolerance: float, optional</span>
<span class="sd">        Argument for get_subarray_closest_sum function. Set the maximum accepted tolerance between the given split ratio</span>
<span class="sd">        and the one got with the obtained subset. Must be a number in [0,1]</span>
<span class="sd">        Default: 0.01</span>
<span class="sd">    perseverance: int, optional</span>
<span class="sd">        Argument for get_subarray_closest_sum function. Set the maximum number of tries before stop searching for a split </span>
<span class="sd">        whose ratio is in the range [target_ratio - tolerance, target_ratio + tolerance]</span>
<span class="sd">        Default: 1000</span>
<span class="sd">    save : bool, optional</span>
<span class="sd">        Whether to save the resulted DataFrame as a .csv file or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    save_path: str, optional</span>
<span class="sd">        A custom path to be used instead of the current working directory. It&#39;s the string given to the </span>
<span class="sd">        pandas.DataFrame.to_csv() method.</span>
<span class="sd">        Default: None</span>
<span class="sd">                 </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    EEGSplit : DataFrame</span>
<span class="sd">        Two columns Pandas DataFrame. The first column has the EEG file name, </span>
<span class="sd">        the second define the file usage with 0-1, Train-Test</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># VARIOUS CHECKS ON INPUTS</span>
    <span class="c1"># check given ratios</span>
    <span class="k">if</span> <span class="n">test_ratio</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">test_ratio</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">test_ratio</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;test_ratio must be in [0,1)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val_ratio</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val_ratio</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">val_ratio</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;val_ratio must be in [0,1)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">test_ratio</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val_ratio</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val_ratio_on_all_data</span> <span class="ow">and</span> <span class="p">((</span><span class="n">val_ratio</span><span class="o">+</span><span class="n">test_ratio</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;if val_ratio_on_all_data is set to true, val_ratio+test_ratio must be in [0,1) &#39;</span><span class="p">)</span>
     
    <span class="c1"># check if given data ids are list or dict</span>
    <span class="k">if</span> <span class="n">exclude_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_data_id</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">exclude_data_id</span><span class="o">=</span><span class="p">[</span><span class="n">exclude_data_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">test_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_data_id</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">test_data_id</span><span class="o">=</span><span class="p">[</span><span class="n">test_data_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">val_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_data_id</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">val_data_id</span><span class="o">=</span><span class="p">[</span><span class="n">val_data_id</span><span class="p">]</span>
        
    <span class="c1"># align split modes to integer</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_split_mode</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">val_split_mode</span> <span class="o">=</span> <span class="n">val_split_mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_split_mode</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">test_split_mode</span> <span class="o">=</span> <span class="n">test_split_mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">val_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;subj&#39;</span><span class="p">,</span> <span class="s1">&#39;subject&#39;</span><span class="p">]:</span>
        <span class="n">val_split_mode</span><span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">val_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;dataset&#39;</span><span class="p">]:</span>
        <span class="n">val_split_mode</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">val_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;record&#39;</span><span class="p">]:</span>
        <span class="n">val_split_mode</span><span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;validation split mode not supported&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">test_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;subj&#39;</span><span class="p">,</span> <span class="s1">&#39;subject&#39;</span><span class="p">]:</span>
        <span class="n">test_split_mode</span><span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">test_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;dataset&#39;</span><span class="p">]:</span>
        <span class="n">test_split_mode</span><span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">test_split_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;record&#39;</span><span class="p">]:</span>
        <span class="n">test_split_mode</span><span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;test split mode not supported&#39;</span><span class="p">)</span>

    <span class="c1"># check if stratification must be applied </span>
    <span class="k">if</span> <span class="n">stratified</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">test_ratio</span><span class="o">==</span><span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val_ratio</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;STRATIFICATION can be applied only if at least one split ratio is given.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">classSplit</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">N_classes</span><span class="p">)</span>
            <span class="c1"># Call the split for each class </span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">N_classes</span><span class="p">):</span>
                <span class="c1">#classIdx= np.where(labels==n)[0]</span>
                <span class="n">classIdx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">index_i</span> <span class="k">for</span> <span class="n">index_i</span><span class="p">,</span> <span class="n">label_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">label_i</span><span class="o">==</span><span class="n">n</span><span class="p">]</span>
                <span class="n">subClassTable</span><span class="o">=</span> <span class="n">partition_table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">classIdx</span><span class="p">]</span>
                <span class="n">classSplit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">GetEEGSplitTable</span><span class="p">(</span><span class="n">partition_table</span><span class="o">=</span><span class="n">subClassTable</span><span class="p">,</span>  
                                                 <span class="n">test_ratio</span><span class="o">=</span><span class="n">test_ratio</span><span class="p">,</span> 
                                                 <span class="n">val_ratio</span> <span class="o">=</span> <span class="n">val_ratio</span><span class="p">,</span>
                                                 <span class="n">test_split_mode</span><span class="o">=</span><span class="n">test_split_mode</span><span class="p">,</span>
                                                 <span class="n">val_split_mode</span><span class="o">=</span><span class="n">val_split_mode</span><span class="p">,</span>
                                                 <span class="n">exclude_data_id</span><span class="o">=</span> <span class="n">exclude_data_id</span><span class="p">,</span>  
                                                 <span class="n">test_data_id</span> <span class="o">=</span><span class="n">test_data_id</span><span class="p">,</span>  
                                                 <span class="n">val_data_id</span> <span class="o">=</span> <span class="n">val_data_id</span><span class="p">,</span>
                                                 <span class="n">val_ratio_on_all_data</span><span class="o">=</span><span class="n">val_ratio_on_all_data</span><span class="p">,</span>
                                                 <span class="n">stratified</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                 <span class="n">dataset_id_extractor</span> <span class="o">=</span> <span class="n">dataset_id_extractor</span><span class="p">,</span>
                                                 <span class="n">subject_id_extractor</span> <span class="o">=</span> <span class="n">subject_id_extractor</span><span class="p">,</span>
                                                 <span class="n">split_tolerance</span><span class="o">=</span><span class="n">split_tolerance</span><span class="p">,</span>
                                                 <span class="n">perseverance</span><span class="o">=</span><span class="n">perseverance</span><span class="p">,</span>
                                                 <span class="n">save</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="p">)</span>
            
            <span class="c1"># merge subclass tables and check for mysterious duplicates</span>
            <span class="n">EEGsplit</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">classSplit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">EEGsplit</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span> <span class="c1">#useless but to be sure</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">EEGsplit</span><span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">EEGsplit</span> <span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;file_name&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">ex_id_list</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">test_id_list</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">test_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">val_id_list</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val_data_id</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="c1"># COPY PARTITION TABLE AND ADD DATASET AND SUBJECT IDS COLUMNS</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition_table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">partition2</span> <span class="o">=</span> <span class="n">partition_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># NOTE: keep the list is faster for access to the data compared to iloc</span>
            <span class="c1"># extract dataset id </span>
            <span class="k">if</span> <span class="n">dataset_id_extractor</span> <span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">dataset_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">dataset_id_extractor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dataset_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">dataset_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]))</span> <span class="p">]</span>
            <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dataset_ID</span>
            <span class="c1"># extract subject id </span>
            <span class="k">if</span> <span class="n">subject_id_extractor</span> <span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">subj_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">subject_id_extractor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">subj_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span> <span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">subj_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]))</span> <span class="p">]</span>
            <span class="n">partition2</span><span class="p">[</span><span class="s1">&#39;subj_ID&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">subj_ID</span>
            <span class="n">EEGfiles</span><span class="o">=</span> <span class="n">partition_table</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="c1"># it&#39;s faster to update a list than a table</span>
        <span class="n">EEGsplit</span><span class="o">=</span><span class="p">[</span> <span class="p">[</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">EEGfiles</span><span class="p">]</span>
        
        <span class="c1"># PRE SPLIT:  DATASET  --&gt;  DATASET WITH ONLY CONSIDERED DATA</span>
        <span class="k">if</span> <span class="n">exclude_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                <span class="n">DatasetID</span> <span class="o">=</span> <span class="n">dataset_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ex_id_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">exclude_data_id</span><span class="p">:</span>
                        <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">SubjID</span> <span class="o">=</span> <span class="n">subj_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">exclude_data_id</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">exclude_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">SubjID</span> <span class="ow">in</span> <span class="n">exclude_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]):</span>
                            <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
        
        <span class="c1"># calculate the sum of all remaining samples after data exclusion</span>
        <span class="c1"># it will be used in train test split (when test ratio is given)</span>
        <span class="c1"># or in train validation split (if validation_on_all_data is set to true)</span>
        <span class="n">idx_val</span><span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGsplit</span><span class="p">))</span> <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">partition2</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx_val</span><span class="p">][</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span>
        <span class="n">alldatasum</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        
        <span class="c1"># FIRST SPLIT:  DATASET  --&gt;  TRAIN/TEST</span>
        <span class="k">if</span> <span class="n">test_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span> 
            <span class="c1"># if test_data_id is given, ignore test ratio and use given IDs</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">DatasetID</span><span class="o">=</span> <span class="n">dataset_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">test_id_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">test_data_id</span><span class="p">:</span>
                            <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">SubjID</span><span class="o">=</span><span class="n">subj_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">test_data_id</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">test_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">SubjID</span> <span class="ow">in</span> <span class="n">test_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]):</span>
                                <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="n">test_ratio</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># split data according to test ratio and test_split_on_subj</span>
            <span class="c1"># group data according to test_split_mode</span>
            <span class="n">partition3</span> <span class="o">=</span> <span class="n">partition2</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx_val</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">test_split_mode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">group1</span> <span class="o">=</span> <span class="n">partition3</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">,</span><span class="s1">&#39;subj_ID&#39;</span><span class="p">]</span> <span class="p">)[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;N_samples&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">test_split_mode</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">group1</span> <span class="o">=</span> <span class="n">partition3</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span> <span class="p">)[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;N_samples&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group1</span> <span class="o">=</span> <span class="n">partition3</span>

            <span class="c1"># get split subarray</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">group1</span><span class="p">[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">target</span><span class="o">=</span><span class="n">test_ratio</span><span class="o">*</span><span class="n">alldatasum</span>
            <span class="n">final_idx</span><span class="p">,</span> <span class="n">subarray</span> <span class="o">=</span> <span class="n">get_subarray_closest_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">split_tolerance</span><span class="p">,</span> <span class="n">perseverance</span><span class="p">)</span>
            <span class="n">final_idx</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># update split list according to returned subarray</span>
            <span class="k">if</span> <span class="n">test_split_mode</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">fileName</span><span class="o">=</span><span class="n">group1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">final_idx</span><span class="p">][</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cntmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">cnt</span><span class="o">==</span><span class="n">cntmax</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">fileName</span><span class="p">[</span><span class="n">cnt</span><span class="p">]:</span>
                        <span class="n">cnt</span> <span class="o">+=</span><span class="mi">1</span>
                        <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">data_test_ID</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">group1</span><span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">final_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">test_split_mode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">subj_test_ID</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_test_ID</span><span class="p">}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">final_idx</span><span class="p">:</span>
                        <span class="n">subj_test_ID</span><span class="p">[</span><span class="n">group1</span><span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">group1</span><span class="p">[</span><span class="s1">&#39;subj_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                        
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">DatasetID</span><span class="o">=</span> <span class="n">dataset_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">data_test_ID</span><span class="p">:</span> 
                            <span class="k">if</span> <span class="n">test_split_mode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">subjID</span><span class="o">=</span><span class="n">subj_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">subjID</span> <span class="ow">in</span> <span class="n">subj_test_ID</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]:</span>
                                    <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    
                        
        <span class="c1"># SECOND SPLIT:  TRAIN  --&gt;  TRAIN/VALIDATION</span>
        <span class="k">if</span> <span class="n">val_data_id</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">DatasetID</span><span class="o">=</span> <span class="n">dataset_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">val_id_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">val_data_id</span><span class="p">:</span>
                            <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">SubjID</span><span class="o">=</span><span class="n">subj_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">val_data_id</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">val_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">SubjID</span> <span class="ow">in</span> <span class="n">val_data_id</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]):</span>
                                <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">val_ratio</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># split data according to test ratio and test_split_on_subj</span>
            <span class="n">idx_val</span><span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGsplit</span><span class="p">))</span> <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">partition3</span> <span class="o">=</span> <span class="n">partition2</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx_val</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val_split_mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group2</span> <span class="o">=</span> <span class="n">partition3</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">,</span><span class="s1">&#39;subj_ID&#39;</span><span class="p">]</span> <span class="p">)[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;N_samples&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">val_split_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">group2</span> <span class="o">=</span> <span class="n">partition3</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span> <span class="p">)[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;N_samples&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group2</span> <span class="o">=</span> <span class="n">partition3</span>
            
            <span class="n">arr</span><span class="o">=</span><span class="n">group2</span><span class="p">[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">target</span><span class="o">=</span><span class="n">val_ratio</span><span class="o">*</span><span class="n">alldatasum</span> <span class="k">if</span> <span class="n">val_ratio_on_all_data</span> <span class="k">else</span> <span class="n">val_ratio</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">final_idx</span><span class="p">,</span> <span class="n">subarray</span> <span class="o">=</span> <span class="n">get_subarray_closest_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">split_tolerance</span><span class="p">,</span> <span class="n">perseverance</span><span class="p">)</span>
            <span class="n">final_idx</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">val_split_mode</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">fileName</span><span class="o">=</span><span class="n">group2</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">final_idx</span><span class="p">][</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cntmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">cnt</span><span class="o">==</span><span class="n">cntmax</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">fileName</span><span class="p">[</span><span class="n">cnt</span><span class="p">]:</span>
                        <span class="n">cnt</span> <span class="o">+=</span><span class="mi">1</span>
                        <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_val_ID</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">group2</span><span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">final_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">val_split_mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">subj_val_ID</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_val_ID</span><span class="p">}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">final_idx</span><span class="p">:</span>
                        <span class="n">subj_val_ID</span><span class="p">[</span><span class="n">group2</span><span class="p">[</span><span class="s1">&#39;dataset_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">group2</span><span class="p">[</span><span class="s1">&#39;subj_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
    
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EEGfiles</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">DatasetID</span><span class="o">=</span> <span class="n">dataset_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">DatasetID</span> <span class="ow">in</span> <span class="n">data_val_ID</span><span class="p">:</span> 
                            <span class="k">if</span> <span class="n">val_split_mode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">subjID</span><span class="o">=</span> <span class="n">subj_ID</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">subjID</span> <span class="ow">in</span> <span class="n">subj_val_ID</span><span class="p">[</span><span class="n">DatasetID</span><span class="p">]:</span>
                                    <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">EEGsplit</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
            
        <span class="n">EEGsplit</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">EEGsplit</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span><span class="s1">&#39;split_set&#39;</span><span class="p">])</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">EEGsplit</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">condition</span><span class="o">=</span><span class="kc">True</span>
                <span class="n">cnt</span><span class="o">=-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="n">condition</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">cnt</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGTrainTestSplit.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGTrainTestSplit_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">EEGsplit</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failed to save file. Function output will be returned but not saved.&#39;</span><span class="p">)</span>      
     
    <span class="k">return</span> <span class="n">EEGsplit</span></div>


<div class="viewcode-block" id="GetEEGSplitTableKfold"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Dataload.GetEEGSplitTableKfold">[docs]</a><span class="k">def</span> <span class="nf">GetEEGSplitTableKfold</span><span class="p">(</span><span class="n">partition_table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                          <span class="n">kfold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                          <span class="n">test_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">test_split_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">int</span> <span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                          <span class="n">val_split_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="n">exclude_data_id</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">test_data_id</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">stratified</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">labels</span><span class="p">:</span> <span class="s1">&#39;array like&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">dataset_id_extractor</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">subject_id_extractor</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">split_tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                          <span class="n">perseverance</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                          <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span>
                         <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;   </span>
<span class="sd">    GetEEGSplitTableKfold create a table with multiple splits for cross-validation.</span>
<span class="sd">    </span>
<span class="sd">    Return a Pandas DataFrame defining multiple training-validation for cross validation applications.</span>
<span class="sd">    Test split, if calculated, is kept equal in every CV split.</span>
<span class="sd">    </span>
<span class="sd">    Split is done in the following way:</span>
<span class="sd">    Dataset --&gt; Train / Test (optional)</span>
<span class="sd">                Train --&gt; Train / Validation  * Fold Number</span>
<span class="sd">    Test split is optional and can be done with the same modalities described in GetEEGSplitTable function, i.e.</span>
<span class="sd">    by giving specific ID or by giving a split ratio. </span>
<span class="sd">    CV&#39;s train/validation split can&#39;t be done in this way, since this does not guarantee the preservation of </span>
<span class="sd">    the split ratio.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partition_table: pd.Dataframe, optional</span>
<span class="sd">        A two columns dataframe where:</span>
<span class="sd">            1-the first column has name &#39;file_name&#39; and contain all the file names</span>
<span class="sd">            2-the second column has name &#39;N_samples&#39; and has the number of samples which can be extracted from the file</span>
<span class="sd">        This table can be automatically created with a custom setting with the provided function GetEEGPartitionNumber()</span>
<span class="sd">        Default: None</span>
<span class="sd">    Kfold: int, optional</span>
<span class="sd">        The number of folds to extract. Must be a number higher or equal than 2.</span>
<span class="sd">        Default: 10</span>
<span class="sd">    test_ratio: float, optional</span>
<span class="sd">        The percentage of data with respect to the whole number of samples (partitions) of the dataset to be included </span>
<span class="sd">        in the test set. Must be a number in [0,1]. 0 means that the test split is skipped if test_data_id isn&#39;t given</span>
<span class="sd">        Default: None</span>
<span class="sd">    test_split_mode: int or str, optional</span>
<span class="sd">        The type of split to perform in the step not_excluded_data --&gt; train / test sets. It can be one of the following:</span>
<span class="sd">            1) any of [0, &#39;d&#39;, &#39;set&#39;, &#39;dataset&#39;] = split will be performed using dataset ids, i.e. all files of the same</span>
<span class="sd">                dataset will be put in the same split set</span>
<span class="sd">            2) any of [1, &#39;s&#39;, &#39;subj&#39;, &#39;subject&#39;] = split will be performed using subjects ids, i.e. all files of the same</span>
<span class="sd">                subjects will be put in the same split set</span>
<span class="sd">            3) any of [2, &#39;file&#39;, &#39;record&#39;] = split will be performed looking at single files</span>
<span class="sd">        Default: 2</span>
<span class="sd">    val_split_mode: int or str, optional</span>
<span class="sd">        The type of split to perform in the step train --&gt; train / validation sets. Input allowed are the same as in</span>
<span class="sd">        test_split_mode.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    exclude_data_id  : list or dict, optional </span>
<span class="sd">        Dataset ID to be excluded. It can be:</span>
<span class="sd">            1) a list with all dataset ids to exclude</span>
<span class="sd">            2) a dictionary where keys are the dataset ids and values its relative subject ids. If a key is store with </span>
<span class="sd">                None as a value, then all the files from that dataset will be included</span>
<span class="sd">        Note1: To work, the function must be able to identify the dataset or subject IDs from the file name in order to check</span>
<span class="sd">            if it is in the list/dict. Custom extraction function can be given as arguments; however, if nothing is given, </span>
<span class="sd">            the function will try to extract IDs considering that file names are in the format a_b_c_d.extension </span>
<span class="sd">            (the output of the AUTO-BIDS library), where &quot;a&quot; is an integer with the dataset ID and &quot;b&quot; an integer </span>
<span class="sd">            with the subject ID. If this fail, all files will be considered from the same datasets (id=0), and each file from a </span>
<span class="sd">            different subject (id from 0 to N-1).</span>
<span class="sd">        Note2: if the input argument is not a list or a dict, it will be automatically converted to a list</span>
<span class="sd">        Default: None</span>
<span class="sd">    test_data_id: list or dict, optional </span>
<span class="sd">        Same as exclude_data_id but for the test split</span>
<span class="sd">        Defaul: None</span>
<span class="sd">    stratified: bool, optional</span>
<span class="sd">        Whether to apply stratification to the split or not. Might be used for fine-tuning split (the only phase where labels</span>
<span class="sd">        are involved). Stratification will preserve, if possible, the label&#39;s ratio on the training/validation/test sets.</span>
<span class="sd">        Works only when each file has an unique label, which must be given in input.</span>
<span class="sd">        Default: False</span>
<span class="sd">    labels: list, array like, optional</span>
<span class="sd">        A list or array like objects with the label of each file listed in the partition table. </span>
<span class="sd">        Must be given if stratification is set to True</span>
<span class="sd">        Indeces of labels must match row indeces in the partition table, i.e. label1 --&gt; row1, label2 --&gt; row2.</span>
<span class="sd">        Default: None</span>
<span class="sd">    dataset_id_extractor: function, optional</span>
<span class="sd">        A custom function to be used to extract the dataset ID from file the file name. It must accept only one argument,</span>
<span class="sd">        which is the file name</span>
<span class="sd">        Default: None</span>
<span class="sd">    subject_id_extractor: function, optional</span>
<span class="sd">        A custom function to be used to extract the subject ID from file the file name. It must accept only one argument,</span>
<span class="sd">        which is the file name</span>
<span class="sd">        Default: None</span>
<span class="sd">    split_tolerance: float, optional</span>
<span class="sd">        Argument for get_subarray_closest_sum function. Set the maximum accepted tolerance between the given split ratio</span>
<span class="sd">        and the one got with the obtained subset. Must be a number in [0,1]</span>
<span class="sd">        Default: 0.01</span>
<span class="sd">    perseverance: int, optional</span>
<span class="sd">        Argument for get_subarray_closest_sum function. Set the maximum number of tries before stop searching for a split </span>
<span class="sd">        whose ratio is in the range [target_ratio - tolerance, target_ratio + tolerance]</span>
<span class="sd">        Default: 1000</span>
<span class="sd">    save : bool, optional</span>
<span class="sd">        Whether to save the resulted DataFrame as a .csv file or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    save_path: str, optional</span>
<span class="sd">        A custom path to be used instead of the current working directory. It&#39;s the string given to the </span>
<span class="sd">        pandas.DataFrame.to_csv() method.</span>
<span class="sd">        Default: None</span>
<span class="sd">                 </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    EEGSplit : DataFrame</span>
<span class="sd">        Two columns Pandas DataFrame. The first column has the EEG file name, </span>
<span class="sd">        the second define the file usage with 0-1, Train-Test</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">if</span> <span class="n">kfold</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kfold must be greater than or equal to 2. &#39;</span>
                         <span class="s1">&#39;If you don</span><span class="se">\&#39;</span><span class="s1">t need multiple splits use the GetEEGSplitTable function&#39;</span>
                        <span class="p">)</span>
    <span class="n">kfold</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">kfold</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">test_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">test_data_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">test_ratio</span> <span class="o">=</span> <span class="mf">0.</span>
        
    <span class="c1"># FIRST STEP: Create test set or exclude data if necessary</span>
    <span class="c1"># the result of this function call will be an initialization of the split table</span>
    <span class="c1"># if no data need to be excluded or placed in a test set, the split_set column will </span>
    <span class="c1"># simply have all zeros.</span>
    <span class="n">EEGsplit</span> <span class="o">=</span> <span class="n">GetEEGSplitTable</span><span class="p">(</span><span class="n">partition_table</span><span class="o">=</span><span class="n">partition_table</span><span class="p">,</span>
                                <span class="n">test_ratio</span><span class="o">=</span> <span class="n">test_ratio</span><span class="p">,</span>
                                <span class="n">test_split_mode</span><span class="o">=</span><span class="n">test_split_mode</span><span class="p">,</span>
                                <span class="n">val_split_mode</span><span class="o">=</span> <span class="n">val_split_mode</span><span class="p">,</span>
                                <span class="n">exclude_data_id</span><span class="o">=</span><span class="n">exclude_data_id</span><span class="p">,</span>
                                <span class="n">test_data_id</span><span class="o">=</span><span class="n">test_data_id</span><span class="p">,</span>
                                <span class="n">val_data_id</span><span class="o">=</span><span class="p">[],</span>
                                <span class="n">stratified</span><span class="o">=</span> <span class="n">stratified</span><span class="p">,</span>
                                <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">,</span>
                                <span class="n">dataset_id_extractor</span> <span class="o">=</span> <span class="n">dataset_id_extractor</span><span class="p">,</span>
                                <span class="n">subject_id_extractor</span> <span class="o">=</span> <span class="n">subject_id_extractor</span><span class="p">,</span>
                                <span class="n">split_tolerance</span><span class="o">=</span><span class="n">split_tolerance</span><span class="p">,</span>
                                <span class="n">perseverance</span><span class="o">=</span><span class="n">perseverance</span>
                               <span class="p">)</span>
    
    <span class="c1"># Find index of elements in train set</span>
    <span class="n">EEGsplit</span> <span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;split_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kfold</span><span class="p">)]})</span>
    <span class="n">idxSplit</span><span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">index</span><span class="p">[(</span><span class="n">EEGsplit</span><span class="p">[</span><span class="s1">&#39;split_set&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">idxAll</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">EEGsplit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">idx2assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">idxAll</span><span class="p">,</span> <span class="n">idxSplit</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kfold</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">EEGsplit</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx2assign</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="n">GetEEGSplitTable</span><span class="p">(</span><span class="n">partition_table</span><span class="o">=</span><span class="n">partition_table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx2assign</span><span class="p">],</span>
                                                      <span class="n">val_ratio</span><span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">kfold</span><span class="o">-</span><span class="n">i</span><span class="p">),</span>
                                                      <span class="n">val_split_mode</span><span class="o">=</span> <span class="n">val_split_mode</span><span class="p">,</span>
                                                      <span class="n">exclude_data_id</span><span class="o">=</span><span class="p">[],</span>
                                                      <span class="n">test_data_id</span><span class="o">=</span><span class="p">[],</span>
                                                      <span class="n">stratified</span><span class="o">=</span> <span class="n">stratified</span><span class="p">,</span>
                                                      <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">idx2assign</span><span class="p">]</span> <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">labels</span><span class="p">,</span>
                                                      <span class="n">dataset_id_extractor</span> <span class="o">=</span> <span class="n">dataset_id_extractor</span><span class="p">,</span>
                                                      <span class="n">subject_id_extractor</span> <span class="o">=</span> <span class="n">subject_id_extractor</span><span class="p">,</span>
                                                      <span class="n">split_tolerance</span><span class="o">=</span><span class="n">split_tolerance</span><span class="p">,</span>
                                                      <span class="n">perseverance</span><span class="o">=</span><span class="n">perseverance</span>
                                                    <span class="p">)[</span><span class="s1">&#39;split_set&#39;</span><span class="p">]</span>
        <span class="n">idxSplit</span><span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">index</span><span class="p">[(</span><span class="n">EEGsplit</span><span class="p">[</span><span class="s1">&#39;split_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">idx2assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">idx2assign</span><span class="p">,</span> <span class="n">idxSplit</span><span class="p">)</span>

    <span class="c1"># assign last fold and delete useless initial split column</span>
    <span class="n">EEGsplit</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx2assign</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">EEGsplit</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;split_set&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">EEGsplit</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">condition</span><span class="o">=</span><span class="kc">True</span>
                <span class="n">cnt</span><span class="o">=-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="n">condition</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">cnt</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGTrainTestSplitKfold.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;EEGTrainTestSplitKfold_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.csv&#39;</span>
                        <span class="n">condition</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">EEGsplit</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failed to save file. Function output will be returned but not saved.&#39;</span><span class="p">)</span>  
    
    <span class="k">return</span> <span class="n">EEGsplit</span></div>



<div class="viewcode-block" id="EEGDataset"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Dataload.EEGDataset">[docs]</a><span class="k">class</span> <span class="nc">EEGDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    EEGlen : DataFrame</span>
<span class="sd">        DataFrame with the number of partition per EEG record. Must be the output of GetEEGPartitionNumber()</span>
<span class="sd">    EEGsplit : DataFrame </span>
<span class="sd">        DataFrame with the train/test split info. Must be the output of GetEEGSplitTable()</span>
<span class="sd">    EEGpartition_spec : list</span>
<span class="sd">        3-element list with the input gave to GetEEGPartitionNumber() in </span>
<span class="sd">        [sampling_rate, window_length, overlap_percentage] format.</span>
<span class="sd">    mode: string, optional</span>
<span class="sd">        if the dataset is intended for train, test or validation. It accept only &#39;train&#39;,&#39;test&#39;,&#39;validation&#39;</span>
<span class="sd">        strings.</span>
<span class="sd">        Default: &#39;train&#39;</span>
<span class="sd">    supervised: bool, optional</span>
<span class="sd">        Whether the getItem method must return a label or not</span>
<span class="sd">        Default: False</span>
<span class="sd">    load_function : &#39;function&#39;, optional</span>
<span class="sd">        A pointer to a custom EEG file loading function. It will be used instead of the default: </span>
<span class="sd">        loadmat(ii, simplify_cells=True)[&#39;DATA_STRUCT&#39;][&#39;data&#39;]</span>
<span class="sd">        The function:</span>
<span class="sd">            1) must take only one required argument, which is the full path to the EEG file </span>
<span class="sd">            2) can output one or two arguments where the first must be the EEG file and the second its (if there is one)</span>
<span class="sd">               label</span>
<span class="sd">        (e.g. the function will be called in this way: load_function(fullpath, optional_arguments) )</span>
<span class="sd">        Note: the assumed number of output is based on the parameter label_on_load. So if the function will return only the </span>
<span class="sd">              EEG remember to set label_on_load on False</span>
<span class="sd">        Default: None</span>
<span class="sd">    transform_function : &#39;function&#39;, optional</span>
<span class="sd">        A pointer to a custom transformation to be applied after the EEG is loaded. Might be useful if there are portion of </span>
<span class="sd">        the signal to cut. </span>
<span class="sd">        The function must take only one required argument, which is the EEG file to transform</span>
<span class="sd">        (e.g. the function will be called in this way: transform_function(EEG, optional_arguments) )</span>
<span class="sd">        Default: None</span>
<span class="sd">    label_function : &#39;function&#39;, optional</span>
<span class="sd">        A pointer to a custom function for the label extraction. Might be useful for the fine-tuning phase. </span>
<span class="sd">        Considering that an EEG file can have single or multiple labels the function will be called with</span>
<span class="sd">        2 required arguments:</span>
<span class="sd">            1) full path to the EEG file </span>
<span class="sd">            2) list with all indeces necessary to identify the extracted partition (if EEG is a 2-D array </span>
<span class="sd">                the list will have only the starting and ending indeces of the slice of the last axis, if the</span>
<span class="sd">                EEG is N-D the list will also add all the other indeces from the first to the second to last axis)</span>
<span class="sd">        e.g. the function will be called in this way: </span>
<span class="sd">                      label_function(full_path, [*first_axis_idx, start, end], optional arguments)</span>
<span class="sd">        NOTE: it is strongly suggested to save EEG labels in a separate file in order to avoid loading every time</span>
<span class="sd">              the entire EEG file which is the purpose of this entire module implementation</span>
<span class="sd">        Default: None</span>
<span class="sd">    optional_load_fun_args: list or dict, optional</span>
<span class="sd">        Optional arguments to give to the custom loading function. Can be a list or a dict.</span>
<span class="sd">        Default: None</span>
<span class="sd">    optional_transform_fun_args: list or dict, optional</span>
<span class="sd">        Optional arguments to give to the EEG transformation function. Can be a list or a dict.</span>
<span class="sd">        Default: None</span>
<span class="sd">    optional_label_fun_args: list or dict, optional</span>
<span class="sd">        Optional arguments to give to the EEG transformation function. Can be a list or a dict.</span>
<span class="sd">        Default: None</span>
<span class="sd">    label_on_load: bool, optional</span>
<span class="sd">        Whether the custom loading function will also load a label associated to the eeg file </span>
<span class="sd">        Default: True</span>
<span class="sd">    label_key: str or list of str, optional</span>
<span class="sd">        A single or set of dictionary keys given as list of strings to use to get access to the label. Might be useful if</span>
<span class="sd">        the loading function will return a dictionary of labels associated to the file, for example when you have a set of </span>
<span class="sd">        patient info but you want to use only a specific one (as in the AUTO-BIDS library)</span>
<span class="sd">        Default: None</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">EEGlen</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
                 <span class="n">EEGsplit</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
                 <span class="n">EEGpartition_spec</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                 <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">,</span>
                 <span class="n">supervised</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">load_function</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transform_function</span><span class="p">:</span> <span class="s1">&#39;function&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label_function</span><span class="p">:</span> <span class="s2">&quot;function&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">optional_load_fun_args</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">optional_transform_fun_args</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">optional_label_fun_args</span><span class="p">:</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label_on_load</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">label_key</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
                <span class="p">):</span>               
        <span class="c1"># Instantiate parent class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="c1"># Store all Input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_dtype</span> <span class="o">=</span> <span class="n">default_dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGsplit</span> <span class="o">=</span> <span class="n">EEGsplit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGlen</span> <span class="o">=</span> <span class="n">EEGlen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supervised</span> <span class="o">=</span> <span class="n">supervised</span>    
        
        <span class="bp">self</span><span class="o">.</span><span class="n">load_function</span> <span class="o">=</span> <span class="n">load_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional_load_fun_args</span> <span class="o">=</span> <span class="n">optional_load_fun_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_function</span> <span class="o">=</span> <span class="n">transform_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional_transform_fun_args</span> <span class="o">=</span> <span class="n">optional_transform_fun_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_function</span> <span class="o">=</span> <span class="n">label_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional_label_fun_args</span> <span class="o">=</span> <span class="n">optional_label_fun_args</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">label_on_load</span> <span class="o">=</span> <span class="n">label_on_load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">label_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span> <span class="o">=</span> <span class="n">label_key</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_key</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">label_key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
        
        <span class="c1"># Check if the dataset is for train test or validation</span>
        <span class="c1"># and extract relative file names</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;train&#39;</span><span class="p">:</span>
            <span class="n">FileNames</span> <span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">EEGsplit</span><span class="p">[</span><span class="s1">&#39;split_set&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;validation&#39;</span><span class="p">:</span>
            <span class="n">FileNames</span> <span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">EEGsplit</span><span class="p">[</span><span class="s1">&#39;split_set&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FileNames</span> <span class="o">=</span> <span class="n">EEGsplit</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">EEGsplit</span><span class="p">[</span><span class="s1">&#39;split_set&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># initialize attributes for __len__ and __getItem__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span> <span class="o">=</span> <span class="n">EEGlen</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">EEGlen</span><span class="p">[</span><span class="s1">&#39;file_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">FileNames</span><span class="p">)]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DatasetSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span><span class="p">[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="c1"># initialize other attributes for __getItem__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">EEGpartition_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">EEGpartition_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">EEGpartition_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="o">=</span> <span class="n">EEGpartition_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">EEGpartition_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EEGcumlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span><span class="p">[</span><span class="s1">&#39;N_samples&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        
        
        <span class="c1"># Set Current EEG loaded attributes (speed up getItem method)</span>
        <span class="c1"># Keep in mind that multiple workers use copy of the dataset</span>
        <span class="c1"># saving a copy of the current loaded EEG file can use lots of memory if EEGs are pretty large</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_info_keys</span><span class="o">=</span><span class="kc">None</span>
        
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">DatasetSize</span>
    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>

        <span class="c1"># Check if a new EEG file must be loaded. If so, a new EEG file is loaded,</span>
        <span class="c1"># transformed (if necessary) and all loading attributes are updated according to the new file</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">index</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">minIdx</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">maxIdx</span><span class="p">)):</span>
            <span class="c1"># Get full path to new file to load </span>
            <span class="n">nameIdx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGcumlen</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">nameIdx</span><span class="p">]</span><span class="o">.</span><span class="n">full_path</span>

            <span class="c1"># load file according to given setting (custom load or not)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_load_fun_args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_load_fun_args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_load_fun_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_load_fun_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">EEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_on_load</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">=</span><span class="n">EEG</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supervised</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">label_info</span> <span class="o">=</span> <span class="n">EEG</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">label_info_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_info_keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">EEG</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span> <span class="o">=</span> <span class="n">EEG</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># load things considering files coming from the auto-BIDS library</span>
                <span class="n">EEG</span><span class="o">=</span><span class="n">loadmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">simplify_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">=</span><span class="n">EEG</span><span class="p">[</span><span class="s1">&#39;DATA_STRUCT&#39;</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supervised</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_on_load</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="o">=</span><span class="n">EEG</span><span class="p">[</span><span class="s1">&#39;DATA_STRUCT&#39;</span><span class="p">][</span><span class="s1">&#39;subj_info&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label_info_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_info_keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_label_keys</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_info</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_key</span><span class="p">]</span>

            <span class="c1"># transform data if transformation function is given</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_transform_fun_args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_transform_fun_args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_transform_fun_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_transform_fun_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">)</span>

            <span class="c1"># convert loaded eeg to torch tensor of specific dtype</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">)</span>

            <span class="c1"># store dimensionality of EEG files (some datasets stored 3D tensors)</span>
            <span class="c1"># This might be helpful for partition selection of multiple EEG in a single file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGlenTrain</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">nameIdx</span><span class="p">]</span><span class="o">.</span><span class="n">N_samples</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># change minimum and maximum index according to new loaded file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minIdx</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="n">nameIdx</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEGcumlen</span><span class="p">[</span><span class="n">nameIdx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxIdx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">EEGcumlen</span><span class="p">[</span><span class="n">nameIdx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>

        
        <span class="c1"># Calculate start and end of the partition</span>
        <span class="c1"># Manage the multidimensional EEG </span>
        <span class="c1"># NOTE: using the if add lines but avoid making useless operation in case of 2D tensors</span>
        <span class="n">partition</span><span class="o">=</span><span class="n">index</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">minIdx</span>
        <span class="n">first_dims_idx</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">cumidx</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimEEG</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">first_dims_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">partition</span><span class="o">-</span><span class="n">cumidx</span><span class="p">)</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">cumidx</span> <span class="o">+=</span> <span class="n">first_dims_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimEEGprod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="o">-</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">partition</span> <span class="o">-</span> <span class="n">cumidx</span><span class="p">)</span>
            <span class="n">end</span><span class="o">=</span><span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span>
            <span class="k">if</span> <span class="n">end</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># in case of partial ending samples</span>
                <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">[</span><span class="o">*</span><span class="n">first_dims_idx</span><span class="p">,:,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">[</span><span class="o">*</span><span class="n">first_dims_idx</span><span class="p">,:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="o">-</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
            <span class="n">end</span><span class="o">=</span><span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span>
            <span class="k">if</span> <span class="n">end</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># in case of partial ending samples</span>
                <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsample</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">currEEG</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>  

        <span class="c1"># extract label if training is supervised (fine-tuning purposes)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supervised</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_on_load</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_label_fun_args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">first_dims_idx</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_label_fun_args</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_label_fun_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">first_dims_idx</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">optional_label_fun_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">first_dims_idx</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">sample</span><span class="p">,</span> <span class="n">label</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">sample</span></div>


<div class="viewcode-block" id="EEGsampler"><a class="viewcode-back" href="../../selfeeg.html#selfeeg.Dataload.EEGsampler">[docs]</a><span class="k">class</span> <span class="nc">EEGsampler</span><span class="p">(</span><span class="n">Sampler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    data_source: EEGDataset</span>
<span class="sd">        The instance of the EEGdataset provided in this module</span>
<span class="sd">    BatchSize: int, optional</span>
<span class="sd">        The size of the batch size used during training. It will be used to create the custom iterator (not linear)</span>
<span class="sd">        Default: 1</span>
<span class="sd">    Workers: Int, optional</span>
<span class="sd">        The number of workers used by the dataloader. It will be used to create the custom iterator (not linear)</span>
<span class="sd">    Mode: int, optional</span>
<span class="sd">        The mode to be used to create the dataloader. it can be 0 or 1, where:</span>
<span class="sd">            1) 0 = the iterator is a simple linear</span>
<span class="sd">            2) 1 = the indeces are first shuffled at the inter-file level, then at the intra-file level; ultimately</span>
<span class="sd">                   all indeces are rearranged based on the batch size and the number of workers in order to reduce</span>
<span class="sd">                   the number of times a new EEG is loaded. The iterator can be seen as a good compromise between </span>
<span class="sd">                   batch heterogeneity and batch creation speed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">data_source</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> 
                 <span class="n">BatchSize</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">Workers</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">Mode</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">Keep_only_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SubjectSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">data_source</span><span class="o">.</span><span class="n">EEGcumlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsubject</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SubjectSamples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchSize</span><span class="o">=</span><span class="n">BatchSize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Workers</span><span class="o">=</span><span class="n">Workers</span> <span class="k">if</span> <span class="n">Workers</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">Mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;supported modes are 0 (linear sampler) and 1 (custom randomization)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Mode</span><span class="o">=</span> <span class="n">Mode</span>
        <span class="k">if</span> <span class="n">Keep_only_ratio</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">Keep_only_ratio</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Keep_only_ratio must be in (0,1]&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Keep_only_ratio</span> <span class="o">=</span> <span class="n">Keep_only_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shrink_data</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">Keep_only_ratio</span><span class="o">&lt;</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">False</span>
        
    
    
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator where subject are passed sequentially for each worker but the samples of each subjects are shuffled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iterator</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">Nseed</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9999999</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mode</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">)))</span>
        
        <span class="c1"># -------------------------------------------------------------</span>
        <span class="c1"># 1st - create a list of shuffled subjects</span>
        <span class="c1"># -------------------------------------------------------------</span>
        <span class="n">SubjList</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsubject</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">Nseed</span><span class="p">)</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">SubjList</span><span class="p">)</span>
        
        <span class="c1"># -------------------------------------------------------------</span>
        <span class="c1"># 2nd - shuffle partitions of the same subject for each subject </span>
        <span class="c1"># -------------------------------------------------------------</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">SubjList</span><span class="p">:</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">Nseed</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SubjectSamples</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">SubjectSamples</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shrink_data</span><span class="p">:</span>
                <span class="n">iterator</span> <span class="o">+=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Keep_only_ratio</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iterator</span> <span class="o">+=</span> <span class="n">idx</span>
         
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># 3rd - Arrange index According to batch and number of workers</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="n">batch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">BatchSize</span>
        <span class="n">worker</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Workers</span>
        <span class="n">Ntot</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>

        <span class="n">Nbatch</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Ntot</span><span class="o">/</span><span class="n">batch</span><span class="p">)</span>
        <span class="n">Nrow</span><span class="p">,</span> <span class="n">Ncol</span> <span class="o">=</span> <span class="n">batch</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nbatch</span><span class="o">/</span><span class="n">worker</span><span class="p">)</span> <span class="p">,</span> <span class="n">worker</span>
        <span class="n">Npad</span><span class="o">=</span> <span class="n">Nrow</span><span class="o">*</span><span class="n">Ncol</span><span class="o">-</span><span class="n">Ntot</span>

        <span class="c1"># Matrix Initialization</span>
        <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nrow</span><span class="p">,</span><span class="n">Ncol</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Assign index to first block of the matrix (Rows until the last batch)</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="n">batch</span><span class="p">,:]</span><span class="o">.</span><span class="n">flat</span><span class="o">=</span><span class="n">iterator</span><span class="p">[:((</span><span class="n">Nrow</span><span class="o">-</span><span class="n">batch</span><span class="p">)</span><span class="o">*</span><span class="n">Ncol</span><span class="p">)]</span>

        <span class="c1"># Assign -1 to the bottom left part of the matrix</span>
        <span class="n">block2</span><span class="o">=</span><span class="p">(</span><span class="n">Ncol</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">Npad</span><span class="o">/</span><span class="n">batch</span><span class="p">))</span>
        <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="n">batch</span><span class="p">:,</span><span class="n">block2</span><span class="p">:]</span><span class="o">=-</span><span class="mi">1</span>

        <span class="c1"># Assign the remaining -1</span>
        <span class="n">block3</span><span class="o">=</span><span class="p">(</span><span class="n">Npad</span><span class="o">-</span><span class="p">(</span><span class="n">Ncol</span><span class="o">-</span><span class="n">block2</span><span class="p">)</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block3</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">b</span><span class="p">[</span><span class="n">Nrow</span><span class="o">-</span><span class="n">block3</span><span class="p">:,</span><span class="n">block2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>


        <span class="c1"># Complete index matrix with the remaining index to insert</span>
        <span class="n">iterator</span><span class="o">=</span><span class="n">iterator</span><span class="p">[((</span><span class="n">Nrow</span><span class="o">-</span><span class="n">batch</span><span class="p">)</span><span class="o">*</span><span class="n">Ncol</span><span class="p">):]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">Nel</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="n">batch</span><span class="o">+</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="n">batch</span><span class="o">+</span><span class="n">i</span><span class="p">,:</span><span class="n">Nel</span><span class="p">]</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">[:</span><span class="n">Nel</span><span class="p">]</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">[</span><span class="n">Nel</span><span class="p">:]</span>
            
        <span class="c1"># Convert matrix to list by scrolling elements according to batchsize and workers</span>
        <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Nrow</span><span class="o">*</span><span class="n">Ncol</span><span class="p">)</span>
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">Rstart</span><span class="o">=-</span><span class="n">batch</span>
        <span class="n">Rend</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Nrow</span><span class="o">/</span><span class="n">batch</span><span class="p">)):</span>
            <span class="n">Rstart</span> <span class="o">+=</span> <span class="n">batch</span>
            <span class="n">Rend</span> <span class="o">+=</span> <span class="n">batch</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncol</span><span class="p">):</span>   
                <span class="n">c</span><span class="p">[</span><span class="n">cnt</span><span class="p">:(</span><span class="n">cnt</span><span class="o">+</span><span class="n">batch</span><span class="p">)]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">Rstart</span><span class="p">:</span><span class="n">Rend</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">batch</span>
        
        <span class="c1"># Remove -1 if there are </span>
        <span class="k">if</span> <span class="n">Npad</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">iterator</span><span class="o">=</span><span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iterator</span><span class="o">=</span><span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">Npad</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, MedMax Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>